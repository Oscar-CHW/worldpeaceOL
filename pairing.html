<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find Match - World Peace Online</title>
    <link rel="stylesheet" href="styles.css">
    <meta name="description" content="Find opponents and join matchmaking in World Peace Online">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        :root {
            --primary: #4CAF50;
            --primary-dark: #3e8e41;
            --secondary: #ff9800;
            --danger: #f44336;
            --light-bg: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .nav-links a {
            color: var(--primary);
            text-decoration: none;
            font-weight: bold;
            padding: 8px 12px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .nav-links a:hover,
        .nav-links a:focus {
            background-color: var(--light-bg);
            outline: none;
            text-decoration: underline;
        }

        .section {
            margin-bottom: 30px;
            background-color: var(--light-bg);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .user-info {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .user-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-right: 20px;
            flex-shrink: 0;
        }

        .user-stats {
            flex: 1;
        }

        .user-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .user-elo {
            font-size: 18px;
            color: var(--primary);
            margin-bottom: 5px;
            font-weight: bold;
            background-color: rgba(76, 175, 80, 0.1);
            padding: 4px 10px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .elo-info {
            font-size: 14px;
            color: #777;
        }

        .options-form {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .elo-range {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            position: relative;
            height: 30px;
        }
        
        .elo-range-bar {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 6px;
            background-color: #ddd;
            border-radius: 3px;
            transform: translateY(-50%);
        }
        
        .elo-range-selection {
            position: absolute;
            top: 50%;
            height: 6px;
            background-color: var(--primary);
            border-radius: 3px;
            transform: translateY(-50%);
        }
        
        .elo-marker {
            position: absolute;
            top: 50%;
            width: 2px;
            height: 12px;
            background-color: #333;
            transform: translateY(-50%);
        }
        
        .elo-marker.your-elo {
            width: 4px;
            background-color: var(--secondary);
        }
        
        .elo-marker::after {
            content: attr(data-elo);
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            white-space: nowrap;
        }
        
        .elo-marker.your-elo::after {
            font-weight: bold;
            color: var(--secondary);
        }

        .queue-status {
            text-align: center;
            padding: 30px 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            display: none;
        }
        
        .status-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status-searching {
            font-size: 18px;
            margin-bottom: 20px;
        }
        
        .status-details {
            background-color: var(--light-bg);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: left;
        }
        
        .status-details p {
            margin: 5px 0;
        }

        .time-elapsed {
            font-size: 32px;
            font-weight: bold;
            margin: 20px 0;
            color: var(--primary);
        }

        .loading-spinner {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .error-message, .success-message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }

        .error-message {
            background-color: #ffebee;
            color: #c62828;
        }

        .success-message {
            background-color: #e8f5e9;
            color: #2e7d32;
        }

        .btn-large {
            padding: 12px 20px;
            font-size: 16px;
            width: 100%;
        }

        .btn-cancel {
            background-color: var(--danger);
        }
        
        .recent-matches {
            margin-top: 30px;
        }
        
        .matches-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .matches-table th {
            background-color: var(--primary);
            color: white;
            text-align: left;
            padding: 12px;
        }
        
        .matches-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }
        
        .matches-table tr:last-child td {
            border-bottom: none;
        }
        
        .matches-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .result-win {
            color: var(--primary);
            font-weight: bold;
        }
        
        .result-loss {
            color: var(--danger);
        }
        
        .result-draw {
            color: #666;
        }
        
        .elo-change {
            font-size: 12px;
            display: inline-block;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
        }
        
        .elo-increase {
            background-color: #e8f5e9;
            color: var(--primary);
        }
        
        .elo-decrease {
            background-color: #ffebee;
            color: var(--danger);
        }
        
        .no-matches {
            text-align: center;
            padding: 20px;
            color: #777;
            font-style: italic;
        }
        
        .tooltip {
            display: inline-block;
            background-color: #f0f0f0;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 12px;
            font-weight: bold;
            color: #555;
            cursor: help;
            position: relative;
            margin-left: 5px;
        }
        
        .tooltip:hover::after,
        .tooltip:focus::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            white-space: nowrap;
            font-weight: normal;
            font-size: 12px;
            z-index: 1;
        }
        
        /* Game-inspired UI elements */
        .premium-match {
            border: 2px solid #ffd700;
            background: linear-gradient(to right, rgba(255,215,0,0.1), rgba(255,215,0,0.3));
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #673ab7;
            color: white;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
        }
        
        /* Accessibility focus styles */
        .tooltip:focus,
        button:focus,
        input:focus,
        a:focus {
            outline: 2px solid #4a69bd;
            outline-offset: 2px;
        }
        
        /* Skip to content link */
        .skip-link {
            position: absolute;
            left: -9999px;
            z-index: 999;
            padding: 1em;
            background-color: white;
            color: black;
            opacity: 0;
        }
        
        .skip-link:focus {
            left: 0;
            opacity: 1;
        }
        
        /* Responsive adjustments */
        @media screen and (max-width: 768px) {
            .page-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .nav-links {
                margin-top: 10px;
                width: 100%;
                justify-content: space-between;
            }
            
            .user-info {
                flex-direction: column;
                text-align: center;
                align-items: center;
            }
            
            .user-avatar {
                margin: 0 0 10px 0;
            }
            
            .form-group input,
            button {
                font-size: 16px; /* Prevent zoom on iOS */
                min-height: 44px; /* Better touch targets */
            }
            
            .container {
                padding: 10px;
            }
            
            .section {
                padding: 15px;
            }
            
            .status-details {
                padding: 10px;
            }
            
            /* Improved table display on mobile */
            .matches-table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
        }

        .searching-container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            text-align: center;
            margin-top: 20px;
            display: none;
        }
        
        .searching-animation {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            border: 6px solid #f3f3f3;
            border-radius: 50%;
            border-top: 6px solid var(--primary);
            animation: spin 1.5s linear infinite;
        }
        
        .queue-time {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary);
            margin: 20px 0;
        }
        
        .search-parameters {
            background-color: var(--light-bg);
            padding: 12px 15px;
            border-radius: 6px;
            display: inline-block;
            margin: 15px auto;
            font-size: 16px;
        }
        
        .matchmaking-mode {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .mode-option {
            flex: 1;
            min-width: 200px;
            background-color: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .mode-option:hover {
            border-color: var(--primary);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .mode-option.active {
            border-color: var(--primary);
            background-color: rgba(76, 175, 80, 0.1);
        }
        
        .mode-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .mode-option h3 {
            margin: 0 0 10px;
            color: var(--primary);
        }
        
        .mode-option p {
            margin: 0;
            color: #555;
            font-size: 14px;
        }
        
        .search-controls {
            display: flex;
            gap: 15px;
        }
        
        .search-controls button {
            flex: 1;
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        #findMatchBtn {
            background-color: var(--primary);
            color: white;
        }
        
        #findMatchBtn:hover {
            background-color: var(--primary-dark);
        }
        
        #cancelSearch {
            background-color: var(--danger);
            color: white;
            display: none;
        }
        
        #cancelSearch:hover {
            background-color: #d32f2f;
        }
        
        .match-found {
            display: none;
            background-color: var(--secondary);
            color: white;
            text-align: center;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 3px 15px rgba(255, 152, 0, 0.4);
            animation: pulse 1.5s infinite;
            margin-top: 20px;
        }
        
        .match-found h3 {
            font-size: 28px;
            margin-top: 0;
        }
        
        .opponent-info {
            background-color: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }
        
        .opponent-info p {
            margin: 5px 0;
            font-size: 18px;
        }
        
        .redirect-msg {
            font-size: 16px;
            font-style: italic;
            margin-top: 20px;
        }

        .player-count {
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            display: inline-block;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .elo-match-good {
            background-color: rgba(76, 175, 80, 0.2);
            color: #2e7d32;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .elo-match-wide {
            background-color: rgba(255, 152, 0, 0.2);
            color: #e65100;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        /* Add responsive improvements */
        @media screen and (max-width: 600px) {
            .matchmaking-mode {
                flex-direction: column;
            }
            
            .mode-option {
                min-width: auto;
            }
            
            .search-controls {
                flex-direction: column;
            }
            
            .queue-time {
                font-size: 22px;
            }
            
            .match-found h3 {
                font-size: 22px;
            }
            
            .opponent-info p {
                font-size: 16px;
            }
        }
        
        /* Add notification permission button styles */
        .notification-permission {
            background-color: var(--light-bg);
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            text-align: center;
        }
        
        .notification-permission button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
        }

        /* Add mobile-specific styles */
        .mobile-only {
            display: none;
        }
        
        @media screen and (max-width: 600px) {
            .mobile-only {
                display: block;
                width: 100%;
                margin-top: 20px;
                padding: 12px;
                background-color: var(--danger);
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
            }
        }

        /* Client-side test panel (hidden by default) */
        .client-test-panel {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            display: none;
        }
        
        .client-test-panel h3 {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .test-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .test-btn {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .test-btn:hover {
            background-color: var(--light-bg);
        }
        
        .test-btn-secondary {
            background-color: var(--danger);
            color: white;
        }
        
        .test-results {
            margin-top: 10px;
        }
        
        .test-summary {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .test-count {
            font-size: 18px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .test-count.failed {
            color: var(--danger);
        }
        
        .test-details {
            margin-top: 10px;
        }
        
        .test-item {
            margin-bottom: 5px;
        }
        
        .test-icon {
            margin-right: 5px;
        }
        
        .test-name {
            font-size: 16px;
            font-weight: bold;
        }
        
        .test-message {
            font-size: 14px;
            color: #555;
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <div class="container" id="main-content">
        <div class="page-header">
            <h1>Find a Match</h1>
            <nav class="nav-links" aria-label="Main navigation">
                <a href="dashboard.html">Dashboard</a>
                <a href="friends.html">Friends</a>
                <a href="index.html">Home</a>
            </nav>
        </div>

        <div id="errorContainer" class="error-message" style="display: none;" role="alert" aria-live="assertive"></div>
        <div id="successContainer" class="success-message" style="display: none;" role="alert" aria-live="assertive"></div>

        <div class="user-info" aria-labelledby="userName">
            <div class="user-avatar" id="userAvatar" aria-hidden="true">?</div>
            <div class="user-stats">
                <div class="user-name" id="userName">Loading...</div>
                <div class="user-elo" id="userElo">ELO: ---</div>
                <div class="elo-info">Your ELO rating determines your skill level and helps match you with players of similar ability.</div>
            </div>
        </div>

        <div class="section" id="matchmakingOptions">
            <h2>Matchmaking Preferences</h2>
            
            <div class="matchmaking-mode" role="radiogroup" aria-labelledby="modeSelection">
                <div id="balancedMode" class="mode-option active" tabindex="0" role="radio" aria-checked="true">
                    <div class="mode-icon">‚öñÔ∏è</div>
                    <h3>Balanced</h3>
                    <p>Find opponents within a moderate ELO range for balanced gameplay.</p>
                </div>
                
                <div id="fastMode" class="mode-option" tabindex="0" role="radio" aria-checked="false">
                    <div class="mode-icon">‚ö°</div>
                    <h3>Fast Match</h3>
                    <p>Find matches quickly with a wider ELO range.</p>
                </div>
                
                <div id="preciseMode" class="mode-option" tabindex="0" role="radio" aria-checked="false">
                    <div class="mode-icon">üéØ</div>
                    <h3>Close Skill</h3>
                    <p>Match with players very close to your ELO (may take longer).</p>
                </div>
            </div>
            
            <div class="search-controls">
                <button id="findMatchBtn" type="button">Find Match</button>
                <button id="cancelSearch" type="button">Cancel</button>
            </div>
        </div>
        
        <div id="searchingContainer" class="searching-container" aria-live="polite">
            <div class="searching-animation" aria-hidden="true"></div>
            <div class="queue-status">Searching for opponents...</div>
            <div class="queue-time" id="queueTime">Time in queue: 0:00</div>
            <div class="search-parameters" id="searchParams">Matching with players around your ELO (1200)</div>
            <div id="notification-permission" class="notification-permission" style="display: none;">
                <p>Get notified when a match is found!</p>
                <button id="enableNotifications">Enable Notifications</button>
            </div>
            <button id="mobileCancelSearch" class="mobile-only">Cancel Search</button>
        </div>
        
        <div id="matchFoundContainer" class="match-found" aria-live="assertive">
            <h3>Match Found!</h3>
            <div class="opponent-info">
                <p>Opponent: <strong id="opponentName">Player</strong></p>
                <p>ELO Rating: <span id="opponentElo">1200</span></p>
            </div>
            <div class="redirect-msg">Redirecting to game room...</div>
        </div>
        
        <div class="section recent-matches">
            <h2>Recent Matches <span id="matchesLoading" class="matches-loading" style="display: none;"></span></h2>
            <div id="recentMatchesList"></div>
        </div>

        <!-- Client-side test panel (hidden by default) -->
        <div id="clientTestPanel" class="client-test-panel" style="display: none;">
            <h3>Client-Side Tests</h3>
            <div class="test-controls">
                <button id="runClientTests" class="test-btn">Run Tests</button>
                <button id="hideTestPanel" class="test-btn test-btn-secondary">Hide Panel</button>
            </div>
            <div id="testResults" class="test-results"></div>
        </div>
    </div>

    <script>
        let queueStartTime = null;
        let timerInterval = null;
        let userData = null;
        let matchmakingMode = 'balanced';
        const socket = io();
        let currentUserCount = 0;
        
        // Add client testing functions
        const clientTests = {
            results: {
                passed: 0,
                failed: 0,
                tests: []
            },
            
            resetResults() {
                this.results = {
                    passed: 0,
                    failed: 0,
                    tests: []
                };
            },
            
            logResult(name, passed, message) {
                if (passed) {
                    this.results.passed++;
                    console.log(`‚úÖ TEST PASSED: ${name} - ${message}`);
                } else {
                    this.results.failed++;
                    console.error(`‚ùå TEST FAILED: ${name} - ${message}`);
                }
                
                this.results.tests.push({ name, passed, message });
                this.updateResultsDisplay();
            },
            
            updateResultsDisplay() {
                const resultsElement = document.getElementById('testResults');
                if (!resultsElement) return;
                
                let html = `
                    <div class="test-summary">
                        <div class="test-count ${this.results.failed > 0 ? 'failed' : 'passed'}">
                            ${this.results.passed} passed, ${this.results.failed} failed
                        </div>
                    </div>
                    <div class="test-details">
                `;
                
                this.results.tests.forEach(test => {
                    html += `
                        <div class="test-item ${test.passed ? 'passed' : 'failed'}">
                            <span class="test-icon">${test.passed ? '‚úÖ' : '‚ùå'}</span>
                            <span class="test-name">${test.name}</span>
                            <span class="test-message">${test.message}</span>
                        </div>
                    `;
                });
                
                html += '</div>';
                resultsElement.innerHTML = html;
            },
            
            async runAllTests() {
                try {
                    this.resetResults();
                    console.log("üß™ Starting client-side tests...");
                    
                    await this.testUIElements();
                    await this.testSocketConnection();
                    await this.testMatchmakingModeSelection();
                    await this.testJoinQueueRequest();
                    
                    // Add UI feedback test
                    const uiFeedbackResults = await testUIFeedback();
                    
                    // Add results to main results object
                    this.results.passed += uiFeedbackResults.passed;
                    this.results.failed += uiFeedbackResults.failed;
                    this.results.tests = this.results.tests.concat(uiFeedbackResults.tests);
                    
                    console.log(`üß™ All tests completed: ${this.results.passed} passed, ${this.results.failed} failed`);
                    
                    // Update display
                    this.updateResultsDisplay();
                } catch (error) {
                    console.error("‚ùå Test execution error:", error);
                    this.logResult("Test Execution", false, `Unexpected error: ${error.message}`);
                }
            },
            
            async testUIElements() {
                try {
                    // Test all required UI elements exist
                    const requiredElements = [
                        { id: 'userElo', name: 'User ELO Display' },
                        { id: 'findMatchBtn', name: 'Find Match Button' },
                        { id: 'balancedMode', name: 'Balanced Mode Option' },
                        { id: 'fastMode', name: 'Fast Mode Option' },
                        { id: 'preciseMode', name: 'Precise Mode Option' },
                        { id: 'searchingContainer', name: 'Searching Container' },
                        { id: 'matchFoundContainer', name: 'Match Found Container' }
                    ];
                    
                    let allElementsExist = true;
                    let missingElements = [];
                    
                    requiredElements.forEach(element => {
                        const el = document.getElementById(element.id);
                        if (!el) {
                            allElementsExist = false;
                            missingElements.push(element.name);
                        }
                    });
                    
                    if (allElementsExist) {
                        this.logResult('UI Elements', true, 'All required UI elements exist');
                    } else {
                        this.logResult('UI Elements', false, `Missing elements: ${missingElements.join(', ')}`);
                    }
                    
                    // Test UI state at initialization
                    const searchingContainer = document.getElementById('searchingContainer');
                    const matchFoundContainer = document.getElementById('matchFoundContainer');
                    
                    if (searchingContainer.style.display === 'none' && matchFoundContainer.style.display === 'none') {
                        this.logResult('UI Initial State', true, 'UI correctly initialized with hidden containers');
                    } else {
                        this.logResult('UI Initial State', false, 'UI incorrectly initialized with visible containers');
                    }
                } catch (error) {
                    this.logResult('UI Elements', false, `Test error: ${error.message}`);
                }
            },
            
            async testSocketConnection() {
                try {
                    // Check if socket is connected
                    if (socket.connected) {
                        this.logResult('Socket Connection', true, 'Socket is connected');
                    } else {
                        this.logResult('Socket Connection', false, 'Socket is not connected');
                        return;
                    }
                    
                    // Test event handling by setting up a temporary listener
                    return new Promise((resolve) => {
                        // Set timeout to fail if event not received
                        const timeout = setTimeout(() => {
                            this.logResult('Socket Event Handling', false, 'Socket event timeout - no response received');
                            resolve();
                        }, 2000);
                        
                        // Set up one-time event handler
                        socket.once('testResponse', (data) => {
                            clearTimeout(timeout);
                            this.logResult('Socket Event Handling', true, 'Socket event handling working properly');
                            resolve();
                        });
                        
                        // Emit test event
                        socket.emit('testRequest', { test: true, timestamp: Date.now() });
                    });
                } catch (error) {
                    this.logResult('Socket Connection', false, `Test error: ${error.message}`);
                }
            },
            
            async testMatchmakingModeSelection() {
                try {
                    // Test mode selection
                    const modes = ['balanced', 'fast', 'precise'];
                    let modeSelectionWorking = true;
                    
                    // Save original mode
                    const originalMode = matchmakingMode;
                    
                    // Try each mode
                    for (const mode of modes) {
                        const modeElement = document.getElementById(`${mode}Mode`);
                        if (!modeElement) {
                            this.logResult('Mode Selection', false, `Mode element '${mode}Mode' not found`);
                            modeSelectionWorking = false;
                            continue;
                        }
                        
                        // Click the mode option
                        modeElement.click();
                        
                        // Check if matchmakingMode was updated
                        if (matchmakingMode !== mode) {
                            this.logResult('Mode Selection', false, `Mode selection failed for ${mode}`);
                            modeSelectionWorking = false;
                            break;
                        }
                        
                        // Check if UI was updated
                        if (!modeElement.classList.contains('active')) {
                            this.logResult('Mode Selection UI', false, `Mode '${mode}' not marked as active in UI`);
                            modeSelectionWorking = false;
                            break;
                        }
                    }
                    
                    if (modeSelectionWorking) {
                        this.logResult('Mode Selection', true, 'Matchmaking mode selection working properly');
                    }
                    
                    // Restore original mode
                    document.getElementById(`${originalMode}Mode`).click();
                } catch (error) {
                    this.logResult('Mode Selection', false, `Test error: ${error.message}`);
                }
            },
            
            async testJoinQueueRequest() {
                try {
                    // Mock the fetch API to prevent actual API calls
                    const originalFetch = window.fetch;
                    
                    // Create a temporary test response
                    const testResponse = {
                        ok: true,
                        json: () => Promise.resolve({ 
                            message: 'Test join successful', 
                            matched: false 
                        })
                    };
                    
                    // Replace fetch with mock
                    window.fetch = function(url, options) {
                        if (url === '/api/pairing/join') {
                            return Promise.resolve(testResponse);
                        }
                        
                        // For other requests, use the original fetch
                        return originalFetch(url, options);
                    };
                    
                    // Store original function to restore later
                    const originalStartSearchingUI = window.startSearchingUI;
                    
                    // Replace with test version
                    let startSearchingCalled = false;
                    window.startSearchingUI = function() {
                        startSearchingCalled = true;
                    };
                    
                    // Call joinMatchmaking
                    await joinMatchmaking();
                    
                    // Restore original functions
                    window.fetch = originalFetch;
                    window.startSearchingUI = originalStartSearchingUI;
                    
                    if (startSearchingCalled) {
                        this.logResult('Join Queue', true, 'Join queue request properly triggers UI update');
                    } else {
                        this.logResult('Join Queue', false, 'Join queue request did not trigger UI update');
                    }
                } catch (error) {
                    this.logResult('Join Queue', false, `Test error: ${error.message}`);
                    
                    // Restore original fetch in case of error
                    if (window.fetch !== originalFetch) {
                        window.fetch = originalFetch;
                    }
                }
            }
        };
        
        // Function to add the test key shortcut and button handler
        function setupTestingTools() {
            // Add keyboard shortcut (Shift+Alt+T) to show test panel
            document.addEventListener('keydown', function(e) {
                if (e.key === 'T' && e.altKey && e.shiftKey) {
                    toggleTestPanel();
                }
            });
            
            // Set up button handlers
            document.getElementById('runClientTests').addEventListener('click', function() {
                clientTests.runAllTests();
            });
            
            document.getElementById('hideTestPanel').addEventListener('click', function() {
                document.getElementById('clientTestPanel').style.display = 'none';
            });
        }
        
        function toggleTestPanel() {
            const panel = document.getElementById('clientTestPanel');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Add loading state
            document.body.setAttribute('aria-busy', 'true');
            
            // Setup Socket.IO listeners
            setupSocketListeners();
            
            // Check authentication and load user data
            checkAuthAndLoadData();

            // Setup matchmaking mode selection
            setupMatchmakingModes();

            // Matchmaking buttons
            document.getElementById('findMatchBtn').addEventListener('click', function() {
                joinMatchmaking();
            });

            document.getElementById('cancelSearch').addEventListener('click', function() {
                leaveMatchmaking();
            });
            
            // Mobile-specific cancel button
            document.getElementById('mobileCancelSearch').addEventListener('click', function() {
                leaveMatchmaking();
            });
            
            // Notification permission button
            document.getElementById('enableNotifications').addEventListener('click', function() {
                requestNotificationPermission();
            });
            
            // Check if browser supports notifications
            if ('Notification' in window) {
                // Show the notification permission section if notifications aren't enabled
                if (Notification.permission !== 'granted') {
                    document.getElementById('notification-permission').style.display = 'block';
                }
            }

            // Check if already in queue
            checkQueueStatus();
            
            // Load recent matches
            loadRecentMatches();
            
            // Make options keyboard accessible
            document.querySelectorAll('.mode-option').forEach(option => {
                option.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.click();
                    }
                });
            });
            
            // Setup testing tools
            setupTestingTools();
            
            // Add socket test handler for client test
            socket.on('testResponse', function(data) {
                console.log('Test response received:', data);
            });
        });
        
        // Add socket test handler on server side test request
        socket.on('testRequest', function(data) {
            // Echo back the data
            socket.emit('testResponse', { 
                received: true, 
                original: data,
                timestamp: Date.now()
            });
        });

        function setupMatchmakingModes() {
            const modes = document.querySelectorAll('.mode-option');
            
            modes.forEach(mode => {
                mode.addEventListener('click', function() {
                    // Remove active class from all modes
                    modes.forEach(m => {
                        m.classList.remove('active');
                        m.setAttribute('aria-checked', 'false');
                    });
                    
                    // Add active class to selected mode
                    this.classList.add('active');
                    this.setAttribute('aria-checked', 'true');
                    
                    // Set matchmaking mode
                    matchmakingMode = this.id.replace('Mode', '');
                    
                    // Update search parameters display
                    updateSearchParameters();
                });
            });
        }
        
        function updateSearchParameters() {
            const paramsElem = document.getElementById('searchParams');
            const userElo = userData ? userData.elo : 1200;
            
            let rangeText = '';
            switch(matchmakingMode) {
                case 'balanced':
                    rangeText = `Matching with players around your ELO (¬±100-200)`;
                    break;
                case 'fast':
                    rangeText = `Matching with a wide range of players (¬±300-400)`;
                    break;
                case 'precise':
                    rangeText = `Matching with players very close to your ELO (¬±50-100)`;
                    break;
                default:
                    rangeText = `Matching with players around your ELO`;
            }
            
            paramsElem.textContent = rangeText;
        }

        // Check authentication and load user data
        async function checkAuthAndLoadData() {
            try {
                const response = await fetch('/api/me');
                if (!response.ok) {
                    throw new Error('Authentication failed');
                }
                
                userData = await response.json();
                
                // Update UI with user data
                document.getElementById('userName').textContent = userData.username;
                document.getElementById('userElo').textContent = `ELO: ${userData.elo}`;
                document.getElementById('userAvatar').textContent = userData.username.charAt(0).toUpperCase();
                
                // Update search parameters display
                updateSearchParameters();
                
                // Announce user data loaded
                announceToScreenReader(`Welcome, ${userData.username}. Your current ELO is ${userData.elo}`);
                
                // Remove loading state
                document.body.removeAttribute('aria-busy');
                
                // Check if user already has a game room
                const roomResponse = await fetch('/api/user/last-room');
                if (roomResponse.ok) {
                    const roomData = await roomResponse.json();
                    
                    if (roomData.hasLastRoom && roomData.roomId) {
                        // Check if the room actually exists via socket
                        socket.emit('checkRoom', { roomId: roomData.roomId });
                        
                        socket.once('roomCheckResult', (checkResult) => {
                            if (checkResult.exists) {
                                showSuccess(`You have an active game room. Redirecting...`);
                                // Directly attempt to join the room
                                attemptToJoinRoom(roomData.roomId, userData.username);
                            } else {
                                // Clear the stale room reference
                                fetch('/api/user/clear-last-room', { method: 'POST' })
                                    .catch(err => console.error('Failed to clear last room:', err));
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Authentication check failed:', error);
                showError('Authentication failed. Redirecting to login page.');
                setTimeout(() => {
                    window.location.href = "/login.html";
                }, 2000);
            }
        }

        // Setup Socket.IO listeners
        function setupSocketListeners() {
            socket.on('connect', () => {
                console.log('Connected to server');
            });
            
            socket.on('error', (data) => {
                showError(data.message);
            });
            
            socket.on('matchFound', (data) => {
                handleMatchFound(data);
            });
            
            socket.on('userCount', (data) => {
                currentUserCount = data.count;
                updatePlayerCount(data.count);
            });
            
            // Handle ping event for debugging
            socket.on('ping', function(data) {
                console.log('Ping received from server:', data);
                // Send pong back to server
                socket.emit('pong', { 
                    received: true, 
                    timestamp: Date.now(),
                    roundTrip: Date.now() - data.timestamp
                });
            });
        }

        // Join matchmaking queue
        async function joinMatchmaking() {
            try {
                // Prepare ELO range based on matchmaking mode
                let eloMin = null;
                let eloMax = null;
                
                // Only set ELO range for precise matching
                if (matchmakingMode === 'precise' && userData) {
                    eloMin = Math.max(userData.elo - 100, 0);
                    eloMax = userData.elo + 100;
                }
                
                // Join queue via API
                const response = await fetch('/api/pairing/join', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ eloMin, eloMax })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    if (data.matched) {
                        // Match found immediately
                        showSuccess('Match found! Redirecting to game room...');
                        setTimeout(() => {
                            window.location.href = `/game-room.html?room=${data.roomId}`;
                        }, 1500);
                    } else {
                        // Start searching UI
                        startSearchingUI();
                    }
                } else {
                    showError(data.error || 'Failed to join matchmaking');
                }
            } catch (error) {
                console.error('Error joining matchmaking:', error);
                showError('Failed to connect to matchmaking server');
            }
        }

        // Leave matchmaking queue
        async function leaveMatchmaking() {
            try {
                const response = await fetch('/api/pairing/leave', {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    stopSearchingUI();
                    showSuccess('Left matchmaking queue');
                } else {
                    const data = await response.json();
                    showError(data.error || 'Failed to leave matchmaking');
                }
            } catch (error) {
                console.error('Error leaving matchmaking:', error);
                showError('Failed to leave matchmaking queue');
            }
        }

        // Check queue status
        async function checkQueueStatus() {
            try {
                const response = await fetch('/api/pairing/status');
                const data = await response.json();
                
                if (data.inQueue) {
                    // Resume searching UI
                    startSearchingUI(new Date(data.joinedAt));
                }
            } catch (error) {
                console.error('Error checking queue status:', error);
            }
        }

        // Start searching UI
        function startSearchingUI(startTime = null) {
            // Hide matchmaking options and show searching container
            document.getElementById('matchmakingOptions').style.display = 'none';
            document.getElementById('searchingContainer').style.display = 'block';
            
            // Update the queue status with the proper message based on matchmaking mode
            let statusMessage = '';
            switch(matchmakingMode) {
                case 'balanced':
                    statusMessage = 'Finding a balanced match with similar skilled players...';
                    break;
                case 'fast':
                    statusMessage = 'Finding the fastest match possible...';
                    break;
                case 'precise':
                    statusMessage = 'Looking for closely matched opponents...';
                    break;
                default:
                    statusMessage = 'Searching for opponents...';
            }
            
            document.querySelector('.queue-status').textContent = statusMessage;
            document.querySelector('.queue-status').style.display = 'block';
            
            // Hide find match button and show cancel button
            document.getElementById('findMatchBtn').style.display = 'none';
            document.getElementById('cancelSearch').style.display = 'block';
            
            // Set queue start time
            queueStartTime = startTime || new Date();
            
            // Start timer
            timerInterval = setInterval(updateQueueTimer, 1000);
            
            // Update search parameters display
            updateSearchParameters();
            
            // Announce to screen readers
            announceToScreenReader('Searching for opponents based on your preferences');
            
            // Show the playerCount if available
            if (currentUserCount > 0) {
                const countElement = document.createElement('div');
                countElement.className = 'player-count';
                countElement.textContent = `${currentUserCount} player${currentUserCount !== 1 ? 's' : ''} online`;
                document.getElementById('searchingContainer').appendChild(countElement);
            }
        }

        // Stop searching UI
        function stopSearchingUI() {
            // Show matchmaking options and hide searching container
            document.getElementById('matchmakingOptions').style.display = 'block';
            document.getElementById('searchingContainer').style.display = 'none';
            
            // Show find match button and hide cancel button
            document.getElementById('findMatchBtn').style.display = 'block';
            document.getElementById('cancelSearch').style.display = 'none';
            
            // Stop timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Reset queue start time
            queueStartTime = null;
            
            // Announce to screen readers
            announceToScreenReader('Search canceled');
        }

        // Update queue timer
        function updateQueueTimer() {
            if (!queueStartTime) return;
            
            const now = new Date();
            const queueTime = now - queueStartTime;
            const minutes = Math.floor(queueTime / 60000);
            const seconds = Math.floor((queueTime % 60000) / 1000);
            
            // Format the time with leading zeros
            const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('queueTime').textContent = `Time in queue: ${formattedTime}`;
            
            // After certain thresholds, update the UI to show expanded search range
            if (minutes >= 1 && matchmakingMode !== 'fast') {
                document.querySelector('.queue-status').textContent = 'Expanding search range to find opponents...';
                
                // Dynamically update the search parameters
                let expandedText = '';
                switch(matchmakingMode) {
                    case 'balanced':
                        expandedText = `Expanded matching range (¬±${100 + Math.min(minutes * 50, 300)})`; 
                        break;
                    case 'precise':
                        expandedText = `Expanded matching range (¬±${50 + Math.min(minutes * 25, 150)})`;
                        break;
                    default:
                        expandedText = 'Expanded matching range';
                }
                document.getElementById('searchParams').textContent = expandedText;
            }
        }

        // Handle match found
        function handleMatchFound(data) {
            // Stop searching UI
            stopSearchingUI();
            
            // Show match found container
            document.getElementById('matchFoundContainer').style.display = 'block';
            
            // Update opponent info
            document.getElementById('opponentName').textContent = data.opponent;
            document.getElementById('opponentElo').textContent = data.opponentElo;
            
            // Add ELO difference display
            if (data.eloDifference !== undefined) {
                const eloDiffText = data.eloDifference === 0 ? 
                    'Perfect ELO match!' : 
                    `ELO difference: ${data.eloDifference}`;
                
                const eloDiffElem = document.createElement('p');
                eloDiffElem.textContent = eloDiffText;
                eloDiffElem.className = data.eloDifference < 100 ? 'elo-match-good' : 'elo-match-wide';
                document.querySelector('.opponent-info').appendChild(eloDiffElem);
            }
            
            // Play a sound to notify the user
            try {
                const audio = new Audio('/sounds/match-found.mp3');
                audio.play().catch(e => console.log('Audio play failed: browser requires user interaction first'));
            } catch (e) {
                console.log('Audio not supported');
            }
            
            // Make the window flash or show notification if possible
            if (document.hidden && 'Notification' in window && Notification.permission === 'granted') {
                try {
                    new Notification('Match Found!', {
                        body: `Your opponent is ${data.opponent} with ELO ${data.opponentElo}`
                    });
                } catch (e) {
                    console.log('Notification failed', e);
                }
            }
            
            // Announce to screen readers
            announceToScreenReader(`Match found! Your opponent is ${data.opponent} with an ELO rating of ${data.opponentElo}`);
            
            // Show a countdown before redirect
            let countdown = 3;
            const redirectMsg = document.querySelector('.redirect-msg');
            redirectMsg.textContent = `Redirecting to game room in ${countdown}...`;
            
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    window.location.href = `/game-room.html?room=${data.roomId}`;
                } else {
                    redirectMsg.textContent = `Redirecting to game room in ${countdown}...`;
                }
            }, 1000);
        }

        // Attempt to join room
        function attemptToJoinRoom(roomId, username) {
            setTimeout(() => {
                window.location.href = `/game-room.html?room=${roomId}`;
            }, 1500);
        }

        // Load recent matches
        async function loadRecentMatches() {
            try {
                // Show loading state
                document.getElementById('matchesLoading').style.display = 'inline-block';
                
                const response = await fetch('/api/matches/recent');
                
                if (response.ok) {
                    const matches = await response.json();
                    renderRecentMatches(matches);
                } else {
                    console.error('Failed to load recent matches');
                    document.getElementById('recentMatchesList').innerHTML = 
                        '<div class="no-matches" role="alert">Could not load match history</div>';
                }
                
                // Hide loading state
                document.getElementById('matchesLoading').style.display = 'none';
            } catch (error) {
                console.error('Error loading recent matches:', error);
                document.getElementById('matchesLoading').style.display = 'none';
                document.getElementById('recentMatchesList').innerHTML = 
                    '<div class="no-matches" role="alert">Error loading match history</div>';
            }
        }

        // Render recent matches
        function renderRecentMatches(matches) {
            const container = document.getElementById('recentMatchesList');
            
            if (!matches || matches.length === 0) {
                container.innerHTML = '<div class="no-matches" role="status">No recent matches found</div>';
                return;
            }
            
            let html = `
                <table class="matches-table" aria-label="Recent matches history">
                    <thead>
                        <tr>
                            <th scope="col">Opponent</th>
                            <th scope="col">Result</th>
                            <th scope="col">Date</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            matches.forEach(match => {
                const resultClass = match.result === 'win' ? 'result-win' : 
                                   match.result === 'loss' ? 'result-loss' : 'result-draw';
                
                const eloChangeClass = match.eloChange.startsWith('+') ? 'elo-increase' : 'elo-decrease';
                
                const date = new Date(match.date);
                const formattedDate = date.toLocaleDateString();
                
                html += `
                    <tr>
                        <td>${match.opponent}</td>
                        <td>
                            <span class="${resultClass}">${match.result.toUpperCase()}</span>
                            <span class="elo-change ${eloChangeClass}">${match.eloChange}</span>
                        </td>
                        <td>${formattedDate}</td>
                    </tr>
                `;
            });
            
            html += `
                    </tbody>
                </table>
            `;
            
            container.innerHTML = html;
        }

        // Show error message
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.textContent = message;
            errorContainer.style.display = 'block';
            
            setTimeout(() => {
                errorContainer.style.display = 'none';
            }, 5000);
        }

        // Show success message
        function showSuccess(message) {
            const successContainer = document.getElementById('successContainer');
            successContainer.textContent = message;
            successContainer.style.display = 'block';
            
            setTimeout(() => {
                successContainer.style.display = 'none';
            }, 5000);
        }
        
        // Announce to screen readers
        function announceToScreenReader(message) {
            // You could add an actual live region for this, but we'll use the existing ones
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.textContent = message;
            errorContainer.style.display = 'block';
            
            setTimeout(() => {
                errorContainer.style.display = 'none';
            }, 5000);
        }

        // Request notification permission
        function requestNotificationPermission() {
            if (!('Notification' in window)) {
                alert('This browser does not support desktop notification');
                return;
            }
            
            Notification.requestPermission().then(function(permission) {
                if (permission === 'granted') {
                    document.getElementById('notification-permission').style.display = 'none';
                    showSuccess('Notifications enabled!');
                    
                    // Send a test notification
                    try {
                        new Notification('Notifications Enabled', {
                            body: 'You will be notified when a match is found'
                        });
                    } catch (e) {
                        console.log('Test notification failed', e);
                    }
                }
            });
        }

        // Add function to test UI state transitions
        async function testUIFeedback() {
            console.log('üß™ Testing UI feedback and state transitions...');
            const results = {
                passed: 0,
                failed: 0,
                tests: []
            };
            
            try {
                // Save original UI state
                const searchingDisplay = document.getElementById('searchingContainer').style.display;
                const matchFoundDisplay = document.getElementById('matchFoundContainer').style.display;
                const optionsDisplay = document.getElementById('matchmakingOptions').style.display;
                
                // Test searching UI
                console.log('Testing searching UI state...');
                startSearchingUI();
                
                // Verify search UI is shown
                if (document.getElementById('searchingContainer').style.display === 'block' &&
                    document.getElementById('matchmakingOptions').style.display === 'none') {
                    console.log('‚úÖ PASS: Searching UI displayed correctly');
                    results.passed++;
                    results.tests.push({ name: 'Searching UI', passed: true });
                } else {
                    console.error('‚ùå FAIL: Searching UI not displayed correctly');
                    results.failed++;
                    results.tests.push({ name: 'Searching UI', passed: false });
                }
                
                // Test match found UI
                console.log('Testing match found UI state...');
                handleMatchFound({
                    roomId: 'TEST-ROOM',
                    opponent: 'TestOpponent',
                    opponentElo: 1200,
                    eloDifference: 0
                });
                
                // Verify match found UI is shown
                if (document.getElementById('matchFoundContainer').style.display === 'block' &&
                    document.getElementById('searchingContainer').style.display === 'none') {
                    console.log('‚úÖ PASS: Match found UI displayed correctly');
                    results.passed++;
                    results.tests.push({ name: 'Match Found UI', passed: true });
                } else {
                    console.error('‚ùå FAIL: Match found UI not displayed correctly');
                    results.failed++;
                    results.tests.push({ name: 'Match Found UI', passed: false });
                }
                
                // Test countdown display
                console.log('Testing countdown display...');
                // Simulate countdown
                let countdownWorks = true;
                for (let i = 3; i >= 0; i--) {
                    document.getElementById('countdown').innerText = i;
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    if (document.getElementById('countdown').innerText != i.toString()) {
                        countdownWorks = false;
                    }
                }
                
                if (countdownWorks) {
                    console.log('‚úÖ PASS: Countdown display works correctly');
                    results.passed++;
                    results.tests.push({ name: 'Countdown Display', passed: true });
                } else {
                    console.error('‚ùå FAIL: Countdown display not working correctly');
                    results.failed++;
                    results.tests.push({ name: 'Countdown Display', passed: false });
                }
                
                // Restore original state
                document.getElementById('searchingContainer').style.display = searchingDisplay;
                document.getElementById('matchFoundContainer').style.display = matchFoundDisplay;
                document.getElementById('matchmakingOptions').style.display = optionsDisplay;
                
                console.log(`üß™ UI test results: ${results.passed} passed, ${results.failed} failed`);
                return results;
            } catch (error) {
                console.error('‚ùå Error testing UI feedback:', error);
                results.failed++;
                results.tests.push({ name: 'UI Testing', passed: false, error: error.message });
                return results;
            }
        }
    </script>
</body>
</html> 