const express = require('express');
const path = require('path');
const bcrypt = require('bcrypt');
const session = require('express-session');
const cookieParser = require('cookie-parser');
const prisma = require('./prisma/client');
const { createServer } = require('http');
const { Server } = require('socket.io');
const fs = require('fs');
const readline = require('readline');
const SQLiteStore = require('connect-sqlite3')(session);
// Add passport and Google OAuth support
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
// Add dotenv for environment variables
require('dotenv').config();

// Server configuration
const DEBUG_MODE = process.env.DEBUG_MODE === 'true';
let VERBOSE_LOGGING = process.env.VERBOSE_LOGGING === 'true';

// Enable verbose logging for development
if (process.env.NODE_ENV !== 'production') {
  console.log('Enabling verbose logging for development');
  VERBOSE_LOGGING = true;
}

// Logging function for consistent server logs
function log(message, level = 'info', category = null) {
  if (level === 'error') {
    serverStats.errors++;
    console.error(`[ERROR] ${message}`);
    return;
  }
  
  // Skip logging if verbose mode disabled and level is debug
  if (level === 'debug' && !VERBOSE_LOGGING) {
    return;
  }
  
  // Skip logging if category is disabled
  if (category && logCategories[category] === false) {
    return;
  }
  
  // Format and output the log
  const timestamp = new Date().toISOString();
  let logPrefix = `[${timestamp}]`;
  
  if (level === 'info') logPrefix += ' [INFO]';
  if (level === 'warn') logPrefix += ' [WARN]';
  if (level === 'debug') logPrefix += ' [DEBUG]';
  if (level === 'success') logPrefix += ' [SUCCESS]';
  
  if (category) {
    logPrefix += ` [${category}]`;
  }
  
  console.log(`${logPrefix} ${message}`);
}

// Server data structures
const rooms = new Map(); // Store game rooms
let onlineUserCount = 0; // Track number of connected users
const connectedUsers = new Set(); // Track connected socket IDs
const userRooms = new Map(); // Map socket IDs to room IDs

// Game mode configurations
const gameModes = {
  classic: {
    name: "Classic",
    description: "Standard game mode with balanced gameplay.",
    initialGold: 500,
    miningRate: 50,
    unitStats: {
      miner: { health: 100, speed: 1.0, cost: 100 },
      soldier: { health: 200, damage: 10, speed: 1.0, cost: 200 },
      barrier: { health: 300, cost: 50 }
    }
  },
  insane: {
    name: "Insane",
    description: "Fast-paced chaos with powerful units and rapid resource generation.",
    initialGold: 1000,
    miningRate: 100,
    unitStats: {
      miner: { health: 80, speed: 1.5, cost: 100 },
      soldier: { health: 250, damage: 20, speed: 1.3, cost: 250 },
      barrier: { health: 500, cost: 75 },
      berserker: { health: 180, damage: 40, speed: 1.8, cost: 400 }
    }
  },
  beta: {
    name: "Beta",
    description: "Experimental features and unique gameplay elements.",
    initialGold: 700,
    miningRate: 65,
    unitStats: {
      miner: { health: 120, speed: 1.0, cost: 120 },
      soldier: { health: 180, damage: 15, speed: 1.0, cost: 220 },
      barrier: { health: 350, cost: 60 },
      scout: { health: 90, damage: 5, speed: 2.0, cost: 150 }
    }
  }
};

// Logging category toggles
const logCategories = {
    CONNECTIONS: true,      // User connections and disconnections
    ROOM_EVENTS: true,      // Room creation, deletion, joining, leaving
    MATCHMAKING: true,      // Matchmaking attempts and results
    GAME_EVENTS: false,     // In-game actions (unit spawning, attacks, etc.)
    PLAYER_READY: false,    // Player ready status changes
    AUTH_EVENTS: false,     // Login, signup, auth events
    ERRORS: true            // Always log errors (can't be disabled)
};

// Server statistics
const serverStats = {
    startTime: new Date(),
    totalConnections: 0,
    matchesMade: 0,
    commandsExecuted: 0,
    errors: 0
};

const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer);
const PORT = process.env.PORT || 3000;

// Express middleware for parsing requests
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());

// Serve static files
app.use(express.static(path.join(__dirname)));
app.use('/images', express.static(path.join(__dirname, 'images')));

// Ensure the db directory exists for sessions
const dbDir = path.join(__dirname, 'db');
if (!fs.existsSync(dbDir)) {
    fs.mkdirSync(dbDir, { recursive: true });
    log('Created db directory for sessions', 'info');
}

// Session configuration with SQLite storage
app.use(session({
    store: new SQLiteStore({ 
        db: 'db/sessions.sqlite'
    }),
    secret: process.env.SESSION_SECRET || 'tianxia-taiping-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: { 
        secure: process.env.NODE_ENV === 'production',
        maxAge: 24 * 60 * 60 * 1000 // 24 hours
    }
}));

// Configure Passport
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: process.env.GOOGLE_CALLBACK_URL,
    passReqToCallback: true
}, async (req, accessToken, refreshToken, profile, done) => {
    try {
        // Try to find a user with this Google ID
        let user = await prisma.user.findUnique({
            where: { googleId: profile.id }
        });
        
        // If we're linking to an existing account (via the /auth/google/link route)
        if (req.session.linkGoogleToUserId) {
            // If a user with this Google ID already exists
            if (user) {
                return done(null, false, { message: 'This Google account is already linked to another user' });
            }
            
            // Get the user from the session
            const existingUser = await prisma.user.findUnique({
                where: { id: req.session.linkGoogleToUserId }
            });
            
            if (!existingUser) {
                return done(null, false, { message: 'User not found' });
            }
            
            // Update the user with Google info
            user = await prisma.user.update({
                where: { id: existingUser.id },
                data: {
                    googleId: profile.id,
                    email: profile.emails[0].value
                }
            });
            
            // Clear the linking flag
            delete req.session.linkGoogleToUserId;
            
            return done(null, user);
        }
        
        // Handle normal login/registration
        if (user) {
            // User found, log them in
            return done(null, user);
        } else {
            // No user found with this Google ID, create a new account
            // Check if a user with this email already exists
            let existingUserByEmail = null;
            if (profile.emails && profile.emails.length > 0) {
                existingUserByEmail = await prisma.user.findUnique({
                    where: { email: profile.emails[0].value }
                });
            }
            
            if (existingUserByEmail) {
                // Update the existing user with Google ID
                user = await prisma.user.update({
                    where: { id: existingUserByEmail.id },
                    data: { googleId: profile.id }
                });
            } else {
                // Create new user
                // Generate a username based on Google profile
                let username = profile.displayName.toLowerCase().replace(/\s+/g, '');
                
                // Check if username exists and append numbers if needed
                let usernameExists = true;
                let counter = 1;
                let finalUsername = username;
                
                while (usernameExists) {
                    const existingUser = await prisma.user.findUnique({
                        where: { username: finalUsername }
                    });
                    
                    if (existingUser) {
                        finalUsername = `${username}${counter}`;
                        counter++;
                    } else {
                        usernameExists = false;
                    }
                }
                
                // Create the new user
                user = await prisma.user.create({
                    data: {
                        username: finalUsername,
                        googleId: profile.id,
                        email: profile.emails[0].value,
                        password: '!GoogleAuth!', // Placeholder, can't be used to log in
                        role: "PLAYER",
                        elo: 1200
                    }
                });
            }
            
            return done(null, user);
        }
  } catch (error) {
        log(`Google auth error: ${error}`, 'error');
        return done(error);
    }
}));

// Serialize/deserialize user for sessions
passport.serializeUser((user, done) => {
    done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
    try {
        const user = await prisma.user.findUnique({
            where: { id: Number(id) }
        });
        done(null, user);
    } catch (error) {
        done(error);
    }
});

app.use(passport.initialize());
app.use(passport.session());

// Set up Socket.IO for real-time communication
io.on('connection', (socket) => {
    // Increment online user count
    onlineUserCount++;
    connectedUsers.add(socket.id);

    log(`User connected: ${socket.id}. Online users: ${onlineUserCount}`, 'info', 'CONNECTIONS');
    io.emit('userCount', { count: onlineUserCount });
    
    // Handle room check requests
    socket.on('checkRoom', (data) => {
        try {
        const { roomId } = data;
            if (!roomId) {
                socket.emit('roomCheckResult', { exists: false, error: 'No room ID provided' });
                return;
            }
            
            log(`Client ${socket.id} checking if room ${roomId} exists`, 'debug');
            const exists = rooms.has(roomId);
            socket.emit('roomCheckResult', { exists });
            
            if (exists) {
                log(`Room ${roomId} exists, notifying client`, 'debug');
            } else {
                log(`Room ${roomId} does not exist`, 'debug');
                
                // If user has this roomId as lastRoom, clear it
                if (socket.request?.session?.userId) {
                    const userId = socket.request.session.userId;
                    prisma.user.findUnique({
                        where: { id: userId }
                    }).then(user => {
                        if (user && user.lastRoom === roomId) {
                            log(`Clearing stale room reference ${roomId} for user ${userId}`, 'info');
                            prisma.user.update({
                                where: { id: userId },
                                data: { lastRoom: null }
                            }).catch(err => log(`Error clearing lastRoom: ${err}`, 'error'));
                        }
                    }).catch(err => log(`Error checking user for lastRoom: ${err}`, 'error'));
                }
            }
        } catch (error) {
            log(`Error checking room: ${error}`, 'error');
            socket.emit('roomCheckResult', { exists: false, error: 'Server error' });
        }
    });
    
    // When user disconnects
    socket.on('disconnect', () => {
        // Decrement online user count
        onlineUserCount = Math.max(0, onlineUserCount - 1);
        connectedUsers.delete(socket.id);
        
        // Handle user leaving a room
        const roomId = userRooms.get(socket.id);
        if (roomId) {
            const room = rooms.get(roomId);
            if (room) {
                // Find the player
                const playerIndex = room.players.findIndex(p => p.socketId === socket.id);
                if (playerIndex !== -1) {
                    // Mark player as disconnected
                    room.players[playerIndex].disconnected = true;
                    room.players[playerIndex].socketId = null;
                    
                    // Notify other players in the room
                    socket.to(roomId).emit('playerList', {
                        players: room.players.filter(p => !p.disconnected || p.socketId === socket.id)
                    });
                    
                    log(`Player ${socket.id} disconnected from room ${roomId}`, 'info', 'CONNECTIONS');
                }
            }
            
            // Remove the user from the room mapping
            userRooms.delete(socket.id);
        }
        
        log(`User disconnected: ${socket.id}. Online users: ${onlineUserCount}`, 'info', 'CONNECTIONS');
        io.emit('userCount', { count: onlineUserCount });
    });
    
    // Handle joining a room
    socket.on('joinRoom', async (data) => {
        try {
            const { roomId, username } = data;
            
            // Validate input
            if (!roomId) {
                log(`Client ${socket.id} attempted to join a room without providing roomId`, 'error');
                socket.emit('error', { message: 'Room ID is required' });
                return;
            }
            
            log(`Client ${socket.id} is attempting to join room ${roomId} as ${username || 'unknown'}`, 'info', 'ROOM_EVENTS');
            
            let userId = null;
            
            // Get user ID from session if authenticated
            if (socket.request.session && socket.request.session.userId) {
                userId = socket.request.session.userId;
                
                const user = await prisma.user.findUnique({
                    where: { id: userId }
                });
                
                if (user) {
                    // Update user's lastRoom
                    await prisma.user.update({
                        where: { id: userId },
                        data: { lastRoom: roomId }
                    });
                    log(`Updated user ${userId} (${username}) lastRoom to ${roomId}`, 'debug', 'ROOM_EVENTS');
                }
            }
            
            // Check if room exists
            let room = rooms.get(roomId);
            
            // Create room if it doesn't exist
            if (!room) {
                log(`Room ${roomId} doesn't exist, creating new room`, 'info', 'ROOM_EVENTS');
                room = {
                    Started: false,
                    gameMode: 'classic', // Default game mode
                players: [{
                    socketId: socket.id,
                        username: username || 'Player1',
                        isHost: true,
                        userId: userId,
                        disconnected: false,
                        ready: true  // Host is automatically ready
                    }],
                    serverGameState: {
                        started: false,
                        gold: {},
                        units: [],
                        hp: {},
                        lastUpdateTime: Date.now()
                    }
                };
                
                rooms.set(roomId, room);
                log(`Room created: ${roomId} with host ${username || socket.id}`, 'info', 'ROOM_EVENTS');
            } else {
                // Check if player is already in the room
                const existingPlayer = room.players.find(p => 
                    p.userId === userId || 
                    p.socketId === socket.id || 
                    (username && p.username === username)
                );
                
                if (existingPlayer) {
                    // Update existing player's socket ID and connection status
                    existingPlayer.socketId = socket.id;
                    existingPlayer.disconnected = false;
                    log(`Player ${username || socket.id} reconnected to room ${roomId}`, 'info', 'ROOM_EVENTS');
                } else {
                    // Add new player to the room
                    room.players.push({ 
                        socketId: socket.id,
                        username: username || `Player${room.players.length + 1}`,
                        isHost: false,
                        userId: userId,
                        disconnected: false
                    });
                    log(`Player ${username || socket.id} joined room ${roomId}`, 'info', 'ROOM_EVENTS');
                }
            }
            
            // Join the socket.io room
            socket.join(roomId);
            userRooms.set(socket.id, roomId);
            
            log(`Socket ${socket.id} joined room ${roomId}`, 'debug', 'ROOM_EVENTS');
            
            // Send room data to all clients in the room
            io.to(roomId).emit('playerList', {
                players: room.players.filter(p => !p.disconnected),
                gameMode: room.gameMode
            });
            
            // Notify the client that they've joined successfully
            socket.emit('roomJoined', {
                roomId,
                isHost: room.players.find(p => p.socketId === socket.id)?.isHost || false,
                gameMode: room.gameMode
            });
            
            log(`Emitted roomJoined event to client ${socket.id} for room ${roomId}`, 'debug', 'ROOM_EVENTS');
            
            // If the game has already started, notify the client
            if (room.Started) {
                socket.emit('gameStarted', { gameState: room.gameState });
                log(`Game already started, sending gameState to new player ${socket.id}`, 'debug', 'ROOM_EVENTS');
            }
        } catch (error) {
            log(`Error joining room: ${error}`, 'error');
                    socket.emit('error', { message: 'Failed to join room' });
        }
    });
    
    // Handle unit movement updates from clients
    socket.on('unitMove', (data) => {
        const { unitId, x, y } = data;
        const roomId = userRooms.get(socket.id);
        if (!roomId) return;
        
        const room = rooms.get(roomId);
        if (!room || !room.gameState) return;
        
        // Find the unit in server-side state
        const unitIndex = room.serverGameState.units.findIndex(u => u.id === unitId);
        if (unitIndex === -1) return;
        
        // Validate that this player owns the unit (anti-cheat)
        const unit = room.serverGameState.units[unitIndex];
        if (unit.playerId !== socket.id) {
            log(`Rejected move - Player ${socket.id} tried to move unit owned by ${unit.playerId}`, 'warn');
                return;
            }
            
        // Get game mode config for movement speed limits
        const gameMode = room.gameMode || 'classic';
        const modeConfig = gameModes[gameMode] || gameModes.classic;
        const unitStats = modeConfig.unitStats[unit.type] || {};
        
        // Check movement speed (basic anti-cheat)
        const oldX = unit.x;
        const oldY = unit.y;
        const dx = x - oldX;
        const dy = y - oldY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Max allowed movement per update (could be refined further)
        const maxSpeed = (unitStats.speed || 1) * 10;
        
        if (dist > maxSpeed) {
            log(`Rejected move - Unit ${unitId} attempted to move too fast (${dist} > ${maxSpeed})`, 'warn');
            
            // Notify the client of the correct position
            socket.emit('unitPositionCorrection', {
                unitId,
                x: oldX, 
                y: oldY
            });
                return;
        }
        
        // Update position in server state
        room.serverGameState.units[unitIndex].x = x;
        room.serverGameState.units[unitIndex].y = y;
        
        // Also update in game state
        const gameUnitIndex = room.gameState.units.findIndex(u => u.id === unitId);
        if (gameUnitIndex !== -1) {
            room.gameState.units[gameUnitIndex].x = x;
            room.gameState.units[gameUnitIndex].y = y;
        }
        
        // Broadcast move to all clients
        io.to(roomId).emit('unitMoved', { unitId, x, y });
    });

    // Handle unit attack events
    socket.on('unitAttack', (data) => {
        const { attackerUnitId, targetUnitId, damage } = data;
        const roomId = userRooms.get(socket.id);
        if (!roomId) return;
        
        const room = rooms.get(roomId);
        if (!room || !room.gameState) return;
        
        // Find both units in server state
        const attacker = room.serverGameState.units.find(u => u.id === attackerUnitId);
        const target = room.serverGameState.units.find(u => u.id === targetUnitId);
        
        if (!attacker || !target) return;
        
        // Validate that this player owns the attacking unit
        if (attacker.playerId !== socket.id) {
            log(`Rejected attack - Player ${socket.id} tried to use unit owned by ${attacker.playerId}`, 'warn');
            return;
        }
        
        // Server-side damage calculation based on unit stats
        const gameMode = room.gameMode || 'classic';
        const modeConfig = gameModes[gameMode] || gameModes.classic;
        const unitStats = modeConfig.unitStats[attacker.type] || {};
        
        // Use server-side damage value instead of client value
        const serverDamage = unitStats.damage || 10;
        
        // Apply damage to target unit
        target.health -= serverDamage;
        
        // Check if unit is destroyed
        if (target.health <= 0) {
            // Remove unit from server state
            room.serverGameState.units = room.serverGameState.units.filter(u => u.id !== targetUnitId);
            // Also remove from game state
            room.gameState.units = room.gameState.units.filter(u => u.id !== targetUnitId);
            
            // Broadcast unit destruction
            io.to(roomId).emit('unitDestroyed', { unitId: targetUnitId });
            log(`Unit ${targetUnitId} destroyed by ${attackerUnitId}`, 'debug');
        } else {
            // Broadcast damage
            io.to(roomId).emit('unitDamaged', { 
                unitId: targetUnitId, 
                health: target.health,
                damageAmount: serverDamage,
                attackerId: attackerUnitId
            });
        }
    });

    // Add handler for setting game mode
    socket.on('setGameMode', (data) => {
        const roomId = userRooms.get(socket.id);
        if (!roomId) {
            socket.emit('error', { message: 'not_in_room' });
            return;
        }
        
        const room = rooms.get(roomId);
        if (!room) {
            socket.emit('error', { message: 'room_not_found' });
            return;
        }
        
        // Check if sender is the host
        const player = room.players.find(p => p.socketId === socket.id);
        if (!player || !player.isHost) {
            socket.emit('error', { message: 'only_host_can_change_mode' });
            return;
        }
        
        // Check if game already started
        if (room.Started) {
            socket.emit('error', { message: 'cannot_change_mode_after_start' });
            return;
        }
        
        // Update game mode
        const newMode = data.mode || 'classic';
        room.gameMode = newMode;
        
        // Notify all players in the room
        io.to(roomId).emit('gameModeChanged', { gameMode: newMode });
        
        log(`Game mode changed to ${newMode} in room ${roomId}`, 'info');
    });

    // Handle ready status
    socket.on('toggleReady', () => {
            const roomId = userRooms.get(socket.id);
            if (!roomId) {
            log(`Socket ${socket.id} tried to toggle ready status but is not in a room`, 'error');
                socket.emit('error', { message: 'not_in_room' });
                return;
            }
            
        const room = rooms.get(roomId);
        if (!room) {
            log(`Socket ${socket.id} tried to toggle ready in room ${roomId}, but room doesn't exist`, 'error');
            socket.emit('error', { message: 'room_not_found' });
            return;
        }
        
        // Find player in the room
        const player = room.players.find(p => p.socketId === socket.id);
        if (!player) {
            log(`Socket ${socket.id} not found in room ${roomId} players list`, 'error');
            socket.emit('error', { message: 'player_not_found' });
            return;
        }
        
        // Don't allow toggling ready state if game has started
        if (room.Started) {
            log(`Socket ${socket.id} tried to toggle ready, but game in room ${roomId} already started`, 'warn');
            socket.emit('error', { message: 'game_already_started' });
            return;
        }
        
        // Don't allow un-readying - only allow setting to ready if not already ready
        if (player.ready) {
            log(`Socket ${socket.id} tried to toggle ready, but already ready`, 'debug');
            socket.emit('error', { message: 'ready_locked' });
            return;
        }
        
        // Set ready status to true (one-way toggle)
        player.ready = true;
        log(`Player ${player.username} (${socket.id}) set ready status to true in room ${roomId}`, 'info', 'PLAYER_READY');
        
        // Notify all players of the updated status
        io.to(roomId).emit('playerList', {
            players: room.players.filter(p => !p.disconnected).map(p => ({
                socketId: p.socketId,
                username: p.username,
                isHost: p.isHost,
                ready: p.ready
            })),
            gameMode: room.gameMode
        });
        
        // Check if all players are ready
        const allPlayersInRoom = room.players.filter(p => !p.disconnected);
        const allPlayersReady = allPlayersInRoom.every(p => p.ready || p.isHost);
        const hasEnoughPlayers = allPlayersInRoom.length >= 2;
        
        const allReady = hasEnoughPlayers && allPlayersReady;
        
        log(`Room ${roomId} ready check: players=${allPlayersInRoom.length}, allReady=${allPlayersReady}, hasEnoughPlayers=${hasEnoughPlayers}, startingGame=${allReady}`, 'info', 'PLAYER_READY');
        
        io.to(roomId).emit('allPlayersReady', { 
            ready: allReady,
            readyCount: room.players.filter(p => !p.disconnected && p.ready).length,
            totalCount: allPlayersInRoom.length
        });
        
        // If all players are ready, automatically start the game after a short delay
        if (allReady) {
            log(`All players ready in room ${roomId}, starting game automatically in 3 seconds`, 'info', 'GAME_EVENTS');
            
            // Notify all players that the game is about to start
            io.to(roomId).emit('allPlayersReady', { 
                ready: true,
                readyCount: room.players.filter(p => !p.disconnected && p.ready).length,
                totalCount: allPlayersInRoom.length,
                autoStarting: true
            });
            
            // Set a timer to start the game automatically
            if (!room.autoStartTimer) {
                const countdownStart = 3; // 3 second countdown
                let countdown = countdownStart;
                
                // Send initial countdown notification
                io.to(roomId).emit('autoStartCountdown', { seconds: countdown });
                log(`Sent initial countdown (${countdown}) to room ${roomId}`, 'debug', 'GAME_EVENTS');
                
                // Create countdown interval
                room.countdownInterval = setInterval(() => {
                    countdown--;
                    
                    // Send countdown update to all players
                    io.to(roomId).emit('autoStartCountdown', { seconds: countdown });
                    log(`Sent countdown update (${countdown}) to room ${roomId}`, 'debug', 'GAME_EVENTS');
                    
                    // When countdown reaches 0, clear the interval
                    if (countdown <= 0) {
                        clearInterval(room.countdownInterval);
                        room.countdownInterval = null;
                        log(`Countdown finished for room ${roomId}`, 'debug', 'GAME_EVENTS');
                    }
                }, 1000);
                
                room.autoStartTimer = setTimeout(() => {
                    // Check if the room still exists and the game hasn't started yet
                    if (rooms.has(roomId) && !room.Started) {
                        log(`Auto-starting game in room ${roomId}`, 'info', 'GAME_EVENTS');
                        
                        // Initialize game state with mode-specific settings
                        const gameMode = room.gameMode || 'classic';
                        const modeConfig = gameModes[gameMode] || gameModes.classic;
                        
                        room.Started = true;
                        room.gameState = {
                            started: true,
                            mode: gameMode,
                            gold: {},
                            units: [],
                            hp: {}
                        };
                        
                        // Initialize players with mode-specific starting gold
                        room.players.forEach(player => {
                            if (!player.disconnected) {
                                room.gameState.gold[player.socketId] = modeConfig.initialGold;
                                room.gameState.hp[player.socketId] = 100; // Starting HP
                            }
                        });
                        
                        // Copy relevant info to server game state for anti-cheat verification
                        room.serverGameState = {
                            started: true,
                            gold: { ...room.gameState.gold },
                            units: [],
                            hp: { ...room.gameState.hp },
                            lastUpdateTime: Date.now(),
                            modeConfig: modeConfig
                        };
                        
                        // Notify all players that the game has started
                        io.to(roomId).emit('gameStarted', {
                            gameState: room.gameState,
                            modeConfig: {
                                name: modeConfig.name,
                                description: modeConfig.description,
                                initialGold: modeConfig.initialGold,
                                miningRate: modeConfig.miningRate,
                                unitStats: modeConfig.unitStats
                            },
                            players: room.players.filter(p => !p.disconnected).map(p => ({
                                id: p.socketId,
                                username: p.username,
                                isHost: p.isHost,
                                gold: room.gameState.gold[p.socketId],
                                hp: room.gameState.hp[p.socketId]
                            }))
                        });
                        
                        log(`Game auto-started in room ${roomId} with ${room.players.filter(p => !p.disconnected).length} players`, 'success', 'GAME_EVENTS');
                        
                        // Start mining income for all players
                        startMiningIncome(roomId, modeConfig.miningRate);
        } else {
                        log(`Cannot auto-start game: room ${roomId} no longer exists or game already started`, 'warn', 'GAME_EVENTS');
                    }
                    
                    // Clear the timer reference
                    if (room) {
                        room.autoStartTimer = null;
                        
                        // Also clear countdown interval if it exists
                        if (room.countdownInterval) {
                            clearInterval(room.countdownInterval);
                            room.countdownInterval = null;
                        }
                    }
                }, 3000); // 3 second delay before auto-start
            }
        }
    });

    // Handle game start request
    socket.on('startGame', () => {
        const roomId = userRooms.get(socket.id);
        if (!roomId) {
            socket.emit('error', { message: 'not_in_room' });
            return;
        }
        
        const room = rooms.get(roomId);
        if (!room) {
            socket.emit('error', { message: 'room_not_found' });
            return;
        }
        
        // Check if sender is the host
        const player = room.players.find(p => p.socketId === socket.id);
        if (!player || !player.isHost) {
            socket.emit('error', { message: 'only_host_can_start_game' });
            return;
        }
        
        // Check if the game has already started
        if (room.Started) {
            socket.emit('error', { message: 'game_already_started' });
            return;
        }
        
        // Check if we have enough players (at least 2)
        if (room.players.filter(p => !p.disconnected).length < 2) {
            socket.emit('error', { message: 'need_at_least_two_players' });
            return;
        }
        
        // Check if all players are ready
        const allReady = room.players.filter(p => !p.disconnected).every(p => p.ready || p.isHost);
        if (!allReady) {
            socket.emit('error', { message: 'not_all_players_ready' });
            return;
        }
        
        // Get game mode configuration
        const gameMode = room.gameMode || 'classic';
        const modeConfig = gameModes[gameMode] || gameModes.classic;
        
        log(`Starting game in room ${roomId} with mode: ${gameMode}`, 'info', 'GAME_EVENTS');
        
        // Initialize game state with mode-specific settings
        room.Started = true;
        room.gameState = {
            started: true,
            mode: gameMode,
            gold: {},
            units: [],
            hp: {}
        };
        
        // Initialize players with mode-specific starting gold
        room.players.forEach(player => {
            if (!player.disconnected) {
                room.gameState.gold[player.socketId] = modeConfig.initialGold;
                room.gameState.hp[player.socketId] = 100; // Starting HP
            }
        });
        
        // Copy relevant info to server game state for anti-cheat verification
        room.serverGameState = {
            started: true,
            gold: { ...room.gameState.gold },
            units: [],
            hp: { ...room.gameState.hp },
            lastUpdateTime: Date.now(),
            modeConfig: modeConfig
        };
        
        // Notify all players that the game has started
        io.to(roomId).emit('gameStarted', {
            gameState: room.gameState,
            modeConfig: {
                name: modeConfig.name,
                description: modeConfig.description,
                initialGold: modeConfig.initialGold,
                miningRate: modeConfig.miningRate,
                unitStats: modeConfig.unitStats
            },
            players: room.players.filter(p => !p.disconnected).map(p => ({
                id: p.socketId,
                username: p.username,
                isHost: p.isHost,
                gold: room.gameState.gold[p.socketId],
                hp: room.gameState.hp[p.socketId]
            }))
        });
        
        log(`Game started in room ${roomId} with ${room.players.filter(p => !p.disconnected).length} players`, 'success', 'GAME_EVENTS');
        
        // Start mining income for all players
        startMiningIncome(roomId, modeConfig.miningRate);
    });
    
    // Add this function to handle mining income for the room
    function startMiningIncome(roomId, miningRate) {
        const room = rooms.get(roomId);
        if (!room || !room.Started) return;
        
        // Clear any existing interval
        if (room.miningInterval) {
            clearInterval(room.miningInterval);
        }
        
        // Set up mining income interval
        room.miningInterval = setInterval(() => {
            if (!room || !room.Started) {
                clearInterval(room.miningInterval);
            return;
        }
        
            // Add mining income for all connected players
            const activePlayers = room.players.filter(p => !p.disconnected && p.socketId);
            
            activePlayers.forEach(player => {
                // Calculate mining income based on miner units
                let baseIncome = miningRate;
                const playerMiners = room.serverGameState.units.filter(u => 
                    u.type === 'miner' && u.playerId === player.socketId
                );
                
                // Each miner adds 50% of the base mining rate
                const minerBonus = playerMiners.length * (baseIncome * 0.5);
                const totalIncome = baseIncome + minerBonus;
                
                // Update gold in both game state and server state
                room.gameState.gold[player.socketId] += totalIncome;
                room.serverGameState.gold[player.socketId] += totalIncome;
                
                // Notify player of gold update
                io.to(player.socketId).emit('goldUpdate', {
                    playerId: player.socketId,
                    gold: room.gameState.gold[player.socketId],
                    delta: totalIncome
                });
            });
            
            // Send synchronized gold update to all players in the room (for UI)
        io.to(roomId).emit('goldSyncUpdate', {
                players: activePlayers.map(p => ({
                    playerId: p.socketId,
                    gold: room.gameState.gold[p.socketId]
                }))
        });
        }, 5000); // Gold income every 5 seconds
    }

    // Handle unit spawning
    socket.on('spawnUnit', (data) => {
        const roomId = userRooms.get(socket.id);
        if (!roomId) {
            socket.emit('error', { message: 'not_in_room' });
            return;
        }
        
        const room = rooms.get(roomId);
        if (!room || !room.Started) {
            socket.emit('error', { message: 'game_not_started' });
            return;
        }
        
        // Validate unit type
        const unitType = data.unitType;
        if (!unitType) {
            socket.emit('error', { message: 'invalid_unit_type' });
            return;
        }
        
        // Get game mode config
        const gameMode = room.gameMode || 'classic';
        const modeConfig = gameModes[gameMode] || gameModes.classic;
        
        // Check if unit type is valid for this game mode
        if (!modeConfig.unitStats[unitType]) {
            socket.emit('error', { message: 'unit_not_available_in_mode' });
                return;
        }
        
        // Get unit cost from mode config
        const unitStats = modeConfig.unitStats[unitType];
        const cost = unitStats.cost;
        
        // Check if player has enough gold
        const currentGold = room.serverGameState.gold[socket.id] || 0;
        if (currentGold < cost) {
            socket.emit('error', { message: 'not_enough_gold' });
            return;
        }
        
        // Create unit with mode-specific stats
        const unitId = `${unitType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const isLeftPlayer = room.players.findIndex(p => p.socketId === socket.id) === 0;
        
        const unitData = {
            id: unitId,
            type: unitType,
            playerId: socket.id,
            x: data.x || (isLeftPlayer ? 100 : 900),
            y: data.y || 300,
            health: unitStats.health || 100,
            damage: unitStats.damage,
            speed: unitStats.speed,
            isLeftPlayer
        };
        
        // Deduct gold from player
        room.gameState.gold[socket.id] -= cost;
        room.serverGameState.gold[socket.id] -= cost;
        
        // Add unit to game state
        room.gameState.units.push(unitData);
        room.serverGameState.units.push(unitData);
        
        // Notify all players about the new unit
        io.to(roomId).emit('unitSpawned', unitData);
        
        // Update player's gold
        socket.emit('goldUpdate', {
            playerId: socket.id,
            gold: room.gameState.gold[socket.id],
            delta: -cost
        });
        
        log(`Player ${socket.id} spawned ${unitType} in room ${roomId}`, 'debug', 'GAME_EVENTS');
    });
    
    // Handle game end and ELO updates
    socket.on('gameCompleted', async (data) => {
        const roomId = userRooms.get(socket.id);
        if (!roomId) {
            socket.emit('error', { message: 'not_in_room' });
            return;
        }
        
        const room = rooms.get(roomId);
        if (!room) {
            socket.emit('error', { message: 'room_not_found' });
            return;
        }
        
        // Validate the winner is in this room
        const { winnerId } = data;
        const winnerPlayer = room.players.find(p => p.userId === parseInt(winnerId));
        
        if (!winnerPlayer) {
            log(`Invalid winner ID ${winnerId} for room ${roomId}`, 'error');
            socket.emit('error', { message: 'invalid_winner' });
            return;
        }
        
        // Get match ID from room
        const matchId = room.matchId;
        if (!matchId) {
            log(`No match ID found for room ${roomId}`, 'error');
            socket.emit('error', { message: 'match_not_found' });
            return;
        }
        
        log(`Game completed in room ${roomId}, winner: ${winnerPlayer.username} (${winnerId})`, 'info', 'GAME_EVENTS');
        
        // Update ELO ratings
        const eloResult = await updateEloRatings(matchId, parseInt(winnerId));
        
        if (!eloResult) {
            log(`Failed to update ELO ratings for match ${matchId}`, 'error');
            socket.emit('error', { message: 'elo_update_failed' });
            return;
        }
        
        // Notify all players in the room about the game results and ELO changes
        io.to(roomId).emit('gameResults', {
            winner: eloResult.winner,
            loser: eloResult.loser,
            matchId: matchId
        });
        
        log(`Game results sent to room ${roomId}`, 'debug', 'GAME_EVENTS');
        
        // Mark the room as completed
        room.completed = true;
        
        // Schedule room cleanup after a delay to allow players to see results
        setTimeout(() => {
            if (rooms.has(roomId)) {
                log(`Cleaning up completed room ${roomId}`, 'debug', 'ROOM_EVENTS');
                rooms.delete(roomId);
            }
        }, 300000); // 5 minutes
    });
    
    // Handle game mode info request
    socket.on('getGameModes', () => {
        // Send all available game modes to the client
        const modeInfo = Object.keys(gameModes).map(key => ({
            id: key,
            name: gameModes[key].name,
            description: gameModes[key].description,
            initialGold: gameModes[key].initialGold,
            miningRate: gameModes[key].miningRate,
            availableUnits: Object.keys(gameModes[key].unitStats)
        }));
        
        socket.emit('gameModeList', { modes: modeInfo });
        log(`Sent game mode info to client ${socket.id}`, 'debug');
    });
    
    // Improved setGameMode handler
    socket.on('setGameMode', (data) => {
        const roomId = userRooms.get(socket.id);
        if (!roomId) {
            socket.emit('error', { message: 'not_in_room' });
            return;
        }
        
        const room = rooms.get(roomId);
        if (!room) {
            socket.emit('error', { message: 'room_not_found' });
            return;
        }
        
        // Check if sender is the host
        const player = room.players.find(p => p.socketId === socket.id);
        if (!player || !player.isHost) {
            socket.emit('error', { message: 'only_host_can_change_mode' });
            return;
        }
        
        // Check if game already started
        if (room.Started) {
            socket.emit('error', { message: 'cannot_change_mode_after_start' });
            return;
        }
        
        // Update game mode if it's valid
        const newMode = data.mode || 'classic';
        if (!gameModes[newMode]) {
            socket.emit('error', { message: 'invalid_game_mode' });
            return;
        }
        
        room.gameMode = newMode;
        
        // Provide full game mode info to clients
        const modeInfo = {
            id: newMode,
            name: gameModes[newMode].name,
            description: gameModes[newMode].description,
            initialGold: gameModes[newMode].initialGold,
            miningRate: gameModes[newMode].miningRate,
            unitStats: gameModes[newMode].unitStats,
            availableUnits: Object.keys(gameModes[newMode].unitStats)
        };
        
        // Notify all players in the room
        io.to(roomId).emit('gameModeChanged', { 
            gameMode: newMode,
            modeInfo: modeInfo
        });
        
        log(`Game mode changed to ${newMode} in room ${roomId}`, 'info');
    });
});

// ===== Middleware Functions =====

// Authentication middleware
const isAuthenticated = (req, res, next) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  next();
};

// Admin authorization middleware
const isAdmin = async (req, res, next) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.session.userId }
    });
    
    if (!user || user.role !== "ADMIN") {
      return res.status(403).json({ error: 'Admin permission required' });
    }
    
    next();
  } catch (error) {
    console.error('Admin check error:', error);
    res.status(500).json({ error: 'Server error' });
  }
};

// ===== API Routes =====

// ===== Admin API Routes =====

// Get all users (admin only)
app.get('/api/admin/users', isAdmin, async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      select: {
        id: true,
        username: true,
        role: true,
        elo: true,
        banStatus: true,
        createdAt: true,
        updatedAt: true
        // password is intentionally excluded for security
      },
      orderBy: {
        id: 'asc'
      }
    });
    
    res.json(users);
  } catch (error) {
    console.error('Get all users error:', error);
    res.status(500).json({ error: 'Failed to retrieve users' });
  }
});

// Get single user by ID (admin only)
app.get('/api/admin/users/:id', isAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    
    if (isNaN(userId)) {
      return res.status(400).json({ error: 'Invalid user ID' });
    }
    
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        username: true,
        role: true,
        elo: true,
        banStatus: true,
        createdAt: true,
        updatedAt: true
      }
    });
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json(user);
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: 'Failed to retrieve user' });
  }
});

// Update user (admin only)
app.put('/api/admin/users/:id', isAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    
    if (isNaN(userId)) {
      return res.status(400).json({ error: 'Invalid user ID' });
    }
    
    const { username, role, elo } = req.body;
    
    // Validate input
    if (!username) {
      return res.status(400).json({ error: 'Username is required' });
    }
    
    // Validate role
    if (role && !["ADMIN", "PLAYER"].includes(role)) {
      return res.status(400).json({ error: 'Role must be either ADMIN or PLAYER' });
    }
    
    if (typeof elo !== 'undefined' && (isNaN(elo) || elo < 0)) {
      return res.status(400).json({ error: 'ELO must be a non-negative number' });
    }
    
    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: userId }
    });
    
    if (!existingUser) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Check if username is already taken by another user
    if (username !== existingUser.username) {
      const userWithSameUsername = await prisma.user.findUnique({
        where: { username }
      });
      
      if (userWithSameUsername) {
        return res.status(400).json({ error: 'Username already taken' });
      }
    }
    
    // Prepare update data
    const updateData = {
      username,
      ...(role && { role }),
      ...(typeof elo !== 'undefined' && { elo: parseInt(elo) })
    };
    
    // Update user
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: updateData,
      select: {
        id: true,
        username: true,
        role: true,
        elo: true,
        banStatus: true,
        createdAt: true,
        updatedAt: true
      }
    });
    
    res.json(updatedUser);
  } catch (error) {
    console.error('Update user error:', error);
    res.status(500).json({ error: 'Failed to update user' });
  }
});

// Delete user (admin only)
app.delete('/api/admin/users/:id', isAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    
    if (isNaN(userId)) {
      return res.status(400).json({ error: 'Invalid user ID' });
    }
    
    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: userId }
    });
    
    if (!existingUser) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Prevent deleting self
    if (userId === req.session.userId) {
      return res.status(400).json({ error: 'Cannot delete your own account' });
    }
    
    // Delete user
    await prisma.user.delete({
      where: { id: userId }
    });
    
    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

// ===== Regular User API Routes =====

// Signup endpoint
app.post('/api/signup', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Validate input
    if (!username || !password) {
      return res.status(400).json({ error: '用户名和密码是必填项' });
    }
    
    // Check if username already exists
    const existingUser = await prisma.user.findUnique({
      where: { username }
    });
    
    if (existingUser) {
      return res.status(400).json({ error: '用户名已存在' });
    }
    
    // Count total users to determine if this is the first user
    const userCount = await prisma.user.count();
    
    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Create new user
    const newUser = await prisma.user.create({
      data: {
        username,
        password: hashedPassword,
        role: userCount === 0 ? "ADMIN" : "PLAYER", // First user gets ADMIN role, others get PLAYER role
        elo: 1200
      }
    });
    
    // Set session to log in the user automatically
    req.session.userId = newUser.id;
    
    res.status(201).json({
      id: newUser.id,
      username: newUser.username,
      role: newUser.role,
      elo: newUser.elo
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ error: '注册失败，请稍后再试' });
  }
});

// Login endpoint
app.post('/api/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // Validate input
    if (!username || !password) {
      return res.status(400).json({ error: '用户名和密码是必填项' });
    }
    
    // Find user
    const user = await prisma.user.findUnique({
      where: { username }
    });
    
    // User not found or password incorrect
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ error: '用户名或密码错误' });
    }
    
    // Check if user is banned
    if (user.banStatus === "BANNED") {
      return res.status(403).json({ error: '您的账户已被封禁' });
    }
    
    // Set session
    req.session.userId = user.id;
    
    res.json({
      id: user.id,
      username: user.username,
      role: user.role,
      elo: user.elo
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: '登录失败，请稍后再试' });
  }
});

// Logout endpoint
app.post('/api/logout', (req, res) => {
  req.session.destroy(err => {
    if (err) {
      return res.status(500).json({ error: '退出登录失败' });
    }
    res.clearCookie('connect.sid');
    res.json({ message: '已成功退出登录' });
  });
});

// Get current user endpoint
app.get('/api/user/me', isAuthenticated, async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.session.userId }
    });
    
    if (!user) {
      return res.status(404).json({ error: '用户不存在' });
    }
    
    res.json({
      id: user.id,
      username: user.username,
      role: user.role,
      elo: user.elo
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: '获取用户信息失败' });
  }
});

// Add this API endpoint to clear lastRoom
app.post('/api/user/clear-last-room', isAuthenticated, async (req, res) => {
    try {
        // Update user to clear lastRoom field
        await prisma.user.update({
            where: { id: req.session.userId },
            data: { lastRoom: null }
        });
        
        log(`Cleared lastRoom for user ID ${req.session.userId}`, 'info');
        
        res.json({ success: true });
    } catch (error) {
        console.error('Error clearing lastRoom:', error);
        res.status(500).json({ error: 'Server error' });
    }
});

// Existing /api/user/last-room endpoint update to better check room existence
app.get('/api/user/last-room', isAuthenticated, async (req, res) => {
    try {
        const user = await prisma.user.findUnique({
            where: { id: req.session.userId }
        });
        
        if (!user || !user.lastRoom) {
            return res.json({ hasLastRoom: false });
        }
        
        // Check if the room still exists
        const roomExists = rooms.has(user.lastRoom);
        
        // Check if the room has this user as a player
        let isInRoom = false;
        if (roomExists) {
            const room = rooms.get(user.lastRoom);
            isInRoom = room.players.some(p => 
                p.userId === req.session.userId || 
                p.username === user.username
            );
            
            // If room exists but user is not in it, clear the lastRoom reference
            if (!isInRoom) {
                await prisma.user.update({
                    where: { id: req.session.userId },
                    data: { lastRoom: null }
                });
                log(`User ${req.session.userId} not found in room ${user.lastRoom}, cleared lastRoom reference`, 'info');
            }
        } else {
            // Room doesn't exist anymore, clear the lastRoom field
            await prisma.user.update({
                where: { id: req.session.userId },
                data: { lastRoom: null }
            });
            log(`Room ${user.lastRoom} no longer exists, cleared lastRoom for user ${req.session.userId}`, 'info');
        }
        
        // Detailed logging to debug matchmaking
        log(`Last room check for user ${req.session.userId}: roomId=${user.lastRoom}, exists=${roomExists}, isInRoom=${isInRoom}`, 'verbose');
        
        res.json({
            hasLastRoom: roomExists && isInRoom,
            roomId: (roomExists && isInRoom) ? user.lastRoom : null
        });
    } catch (error) {
        console.error('Error checking last room:', error);
        res.status(500).json({ error: 'Server error' });
    }
});

// Get current user info
app.get('/api/me', isAuthenticated, async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.session.userId }
    });
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Return user info without password
    res.json({
      id: user.id,
      username: user.username,
      role: user.role,
      elo: user.elo,
      banStatus: user.banStatus,
      lastRoom: user.lastRoom
    });
  } catch (error) {
    console.error('Error fetching user data:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Friend system API routes
app.post('/api/friends/request', isAuthenticated, async (req, res) => {
  try {
    const { targetUsername } = req.body;
    const senderId = req.session.userId;

    // Find target user
    const targetUser = await prisma.user.findUnique({
      where: { username: targetUsername }
    });

    if (!targetUser) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Check if sending request to self
    if (targetUser.id === senderId) {
      return res.status(400).json({ error: 'You cannot send a friend request to yourself' });
    }

    // Check if friendship already exists
    const existingFriendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { senderId, receiverId: targetUser.id },
          { senderId: targetUser.id, receiverId: senderId }
        ]
      }
    });

    if (existingFriendship) {
      return res.status(400).json({ error: 'Friend request already exists' });
    }

    // Create friendship
    const friendship = await prisma.friendship.create({
      data: {
        senderId,
        receiverId: targetUser.id,
        status: 'pending'
      }
    });

    res.status(201).json(friendship);
  } catch (error) {
    console.error('Error sending friend request:', error);
    res.status(500).json({ error: 'Failed to send friend request' });
  }
});

app.get('/api/friends', isAuthenticated, async (req, res) => {
  try {
    const userId = req.session.userId;

    // Get all accepted friendships where the user is either sender or receiver
    const friendships = await prisma.friendship.findMany({
      where: {
        OR: [
          { senderId: userId, status: 'accepted' },
          { receiverId: userId, status: 'accepted' }
        ]
      },
      include: {
        sender: {
          select: {
            id: true,
            username: true,
            elo: true
          }
        },
        receiver: {
          select: {
            id: true,
            username: true,
            elo: true
          }
        }
      }
    });

    // Format the response
    const friends = friendships.map(friendship => {
      const friend = friendship.senderId === userId 
        ? friendship.receiver 
        : friendship.sender;
      
      return {
        friendshipId: friendship.id,
        userId: friend.id,
        username: friend.username,
        elo: friend.elo
      };
    });

    res.json(friends);
  } catch (error) {
    console.error('Error getting friends:', error);
    res.status(500).json({ error: 'Failed to get friends' });
  }
});

app.get('/api/friends/requests', isAuthenticated, async (req, res) => {
  try {
    const userId = req.session.userId;

    // Get all pending friend requests received by the user
    const friendRequests = await prisma.friendship.findMany({
      where: {
        receiverId: userId,
        status: 'pending'
      },
      include: {
        sender: {
          select: {
            id: true,
            username: true,
            elo: true
          }
        }
      }
    });

    // Format the response
    const requests = friendRequests.map(request => ({
      requestId: request.id,
      from: {
        userId: request.sender.id,
        username: request.sender.username,
        elo: request.sender.elo
      },
      createdAt: request.createdAt
    }));

    res.json(requests);
  } catch (error) {
    console.error('Error getting friend requests:', error);
    res.status(500).json({ error: 'Failed to get friend requests' });
  }
});

app.post('/api/friends/respond', isAuthenticated, async (req, res) => {
  try {
    const { requestId, action } = req.body;
    const userId = req.session.userId;

    if (!['accept', 'reject'].includes(action)) {
      return res.status(400).json({ error: 'Invalid action' });
    }

    // Find the request
    const request = await prisma.friendship.findUnique({
      where: { id: parseInt(requestId) }
    });

    if (!request) {
      return res.status(404).json({ error: 'Friend request not found' });
    }

    // Verify the user is the receiver of this request
    if (request.receiverId !== userId) {
      return res.status(403).json({ error: 'Not authorized to respond to this request' });
    }

    // Update the request
    const updatedRequest = await prisma.friendship.update({
      where: { id: parseInt(requestId) },
      data: { status: action === 'accept' ? 'accepted' : 'rejected' }
    });

    res.json(updatedRequest);
  } catch (error) {
    console.error('Error responding to friend request:', error);
    res.status(500).json({ error: 'Failed to respond to friend request' });
  }
});

app.delete('/api/friends/:friendshipId', isAuthenticated, async (req, res) => {
  try {
    const { friendshipId } = req.params;
    const userId = req.session.userId;

    // Find the friendship
    const friendship = await prisma.friendship.findUnique({
      where: { id: parseInt(friendshipId) }
    });

    if (!friendship) {
      return res.status(404).json({ error: 'Friendship not found' });
    }

    // Check if user is part of this friendship
    if (friendship.senderId !== userId && friendship.receiverId !== userId) {
      return res.status(403).json({ error: 'Not authorized to remove this friendship' });
    }

    // Delete the friendship
    await prisma.friendship.delete({
      where: { id: parseInt(friendshipId) }
    });

    res.json({ message: 'Friend removed successfully' });
  } catch (error) {
    console.error('Error removing friend:', error);
    res.status(500).json({ error: 'Failed to remove friend' });
  }
});

// Friend duel API route
app.post('/api/friends/duel', isAuthenticated, async (req, res) => {
  try {
    const { friendId } = req.body;
    const userId = req.session.userId;

    // Verify the friendship exists and is accepted
    const friendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { senderId: userId, receiverId: parseInt(friendId), status: 'accepted' },
          { senderId: parseInt(friendId), receiverId: userId, status: 'accepted' }
        ]
      }
    });

    if (!friendship) {
      return res.status(404).json({ error: 'This person is not your friend' });
    }

    // Create a new room for the duel
    const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();

    // Return the room ID to redirect the user
    res.json({ roomId });
  } catch (error) {
    console.error('Error initiating friend duel:', error);
    res.status(500).json({ error: 'Failed to initiate duel' });
  }
});

// Open pairing system API endpoints
app.post('/api/pairing/join', isAuthenticated, async (req, res) => {
  try {
    const userId = req.session.userId;
    const { eloMin, eloMax } = req.body;
    
    // Check if user is already in queue
    const existingQueue = await prisma.pairingQueue.findUnique({
      where: { userId }
    });
    
    if (existingQueue) {
      return res.status(400).json({ error: 'You are already in the matchmaking queue' });
    }
    
    // Add user to queue
    const queue = await prisma.pairingQueue.create({
      data: {
        userId,
        eloMin: eloMin ? parseInt(eloMin) : null,
        eloMax: eloMax ? parseInt(eloMax) : null
      }
    });
    
    // Try to find a match immediately
    const matchResult = await tryMatchmaking(userId);
    
    // If match found, no need to create a room as it's already done in tryMatchmaking
    if (matchResult) {
      log(`Match found for user ${userId}, room ${matchResult.roomId} created`, 'success');
      serverStats.matchesMade++;
      
      // Room is already created in tryMatchmaking, just update users' lastRoom
      await prisma.user.update({
        where: { id: matchResult.player1.id },
        data: { lastRoom: matchResult.roomId }
      });
      
      await prisma.user.update({
        where: { id: matchResult.player2.id },
        data: { lastRoom: matchResult.roomId }
      });
      
      log(`Created room ${matchResult.roomId} for matched players: ${matchResult.player1.username} vs ${matchResult.player2.username}`, 'success');
      
      // Start matchmaking interval if not already running
      setupMatchmakingInterval();
      
      return res.status(201).json({ 
        message: 'Match found! Redirecting to game room...',
        matched: true,
        roomId: matchResult.roomId
      });
    } else {
      log(`No immediate match found for user ${userId}, added to queue`, 'info');
      
      // Schedule continuous matchmaking attempts if not already running
      setupMatchmakingInterval();
      
      return res.status(201).json({ 
        message: 'Joined matchmaking queue',
        matched: false
      });
    }
  } catch (error) {
    log(`Error joining matchmaking queue: ${error}`, 'error');
    res.status(500).json({ error: 'Failed to join matchmaking queue' });
  }
});

app.delete('/api/pairing/leave', isAuthenticated, async (req, res) => {
  try {
    const userId = req.session.userId;
    
    // Remove from queue
    await prisma.pairingQueue.deleteMany({
      where: { userId }
    });
    
    res.json({ message: 'Left matchmaking queue' });
  } catch (error) {
    log(`Error leaving matchmaking queue: ${error}`, 'error');
    res.status(500).json({ error: 'Failed to leave matchmaking queue' });
  }
});

app.get('/api/pairing/status', isAuthenticated, async (req, res) => {
  try {
    const userId = req.session.userId;
    
    // Check if in queue
    const queueEntry = await prisma.pairingQueue.findUnique({
      where: { userId }
    });
    
    if (!queueEntry) {
      return res.json({ inQueue: false });
    }
    
    res.json({
      inQueue: true,
      joinedAt: queueEntry.joinedAt,
      eloMin: queueEntry.eloMin,
      eloMax: queueEntry.eloMax
    });
  } catch (error) {
    log(`Error checking queue status: ${error}`, 'error');
    res.status(500).json({ error: 'Failed to check queue status' });
  }
});

// Global variable to track matchmaking interval
let matchmakingIntervalId = null;

// Function to set up periodic matchmaking
function setupMatchmakingInterval() {
  // If matchmaking interval is already set up, don't create another one
  if (matchmakingIntervalId) {
    return;
  }
  
  log('Starting global matchmaking interval', 'info');
  
  // Run matchmaking every 10 seconds
  matchmakingIntervalId = setInterval(async () => {
    try {
      // Find all users in the queue
      const queueEntries = await prisma.pairingQueue.findMany({
        orderBy: { joinedAt: 'asc' },
        include: { user: true }
      });
      
      if (queueEntries.length < 2) {
        return; // Not enough users to match
      }
      
      // Try to match the oldest user in the queue
      await tryMatchmaking(queueEntries[0].userId);
    } catch (error) {
      log(`Error in matchmaking interval: ${error}`, 'error');
    }
  }, 10000);
}

// Function to try matchmaking for a user
async function tryMatchmaking(userId) {
  try {
    // Get user's queue entry and ELO
    const userQueue = await prisma.pairingQueue.findUnique({
      where: { userId },
      include: { user: true }
    });
    
    if (!userQueue) {
      log(`User ${userId} not found in queue`, 'warn', 'MATCHMAKING');
      return null;
    }
    
    const userElo = userQueue.user.elo;
    const username = userQueue.user.username;
    log(`Looking for match for user ${userId} (${username}) with ELO ${userElo}`, 'info', 'MATCHMAKING');
    
    // Determine matchmaking mode based on ELO ranges
    // If no specific ranges are set, assume "balanced" mode
    // If wide range (eloMin is low or eloMax is high), assume "fast" mode
    // If tight range, assume "precise" mode
    let matchmakingMode = "balanced";
    
    if (userQueue.eloMin !== null && userQueue.eloMax !== null) {
      const range = userQueue.eloMax - userQueue.eloMin;
      if (range <= 100) {
        matchmakingMode = "precise";
      } else if (range >= 300) {
        matchmakingMode = "fast";
      }
    } else if (userQueue.eloMin === null && userQueue.eloMax === null) {
      // No preference specified, use balanced
      matchmakingMode = "balanced";
    }
    
    log(`Determined matchmaking mode: ${matchmakingMode} for user ${username}`, 'debug', 'MATCHMAKING');
    
    // Calculate acceptable ELO range based on time in queue and matchmaking mode
    const queueTime = Date.now() - userQueue.joinedAt.getTime();
    const queueTimeMinutes = queueTime / (1000 * 60);
    
    // Set initial ELO range based on matchmaking mode
    let baseEloRange, expansionRate, maxRange;
    
    switch (matchmakingMode) {
      case "precise":
        baseEloRange = 50;    // Start with very tight range
        expansionRate = 25;   // Expand slowly
        maxRange = 200;       // Max moderate range
        break;
      case "fast":
        baseEloRange = 200;   // Start with wide range
        expansionRate = 100;  // Expand quickly
        maxRange = 600;       // Very wide maximum range
        break;
      case "balanced":
      default:
        baseEloRange = 100;   // Moderate initial range
        expansionRate = 50;   // Moderate expansion
        maxRange = 400;       // Moderate maximum range
    }
    
    // Calculate current range based on time in queue
    let eloRange = Math.min(baseEloRange + (queueTimeMinutes * expansionRate), maxRange);
    
    // Respect user-defined limits if stricter than calculated range
    const minElo = userQueue.eloMin !== null 
      ? Math.max(userQueue.eloMin, userElo - eloRange)
      : userElo - eloRange;
      
    const maxElo = userQueue.eloMax !== null 
      ? Math.min(userQueue.eloMax, userElo + eloRange)
      : userElo + eloRange;
    
    log(`ELO matching range for user ${userId} (${matchmakingMode} mode): ${minElo} to ${maxElo} (waited ${queueTimeMinutes.toFixed(2)} minutes)`, 'debug', 'MATCHMAKING');
    
    // Find potential matches based on calculated ELO range
    const potentialMatches = await prisma.pairingQueue.findMany({
      where: {
        userId: { not: userId },
        user: { 
          elo: {
            gte: minElo,
            lte: maxElo
          }
        }
      },
      include: { user: true },
      orderBy: [
        // For precise mode, prioritize closest ELO matches
        // For fast mode, prioritize longest wait time
        // For balanced mode, use a mixed approach
        ...(matchmakingMode === "precise" ? [{ user: { elo: 'asc' }}] : []),
        ...(matchmakingMode === "fast" ? [{ joinedAt: 'asc' }] : []),
        ...(matchmakingMode === "balanced" ? [{ user: { elo: 'asc' }}, { joinedAt: 'asc' }] : [])
      ]
    });
    
    log(`Found ${potentialMatches.length} potential matches for user ${userId}`, 'debug', 'MATCHMAKING');
    
    // Filter matches further based on matched user's ELO preferences
    const compatibleMatches = potentialMatches.filter(match => {
      const matchEloMin = match.eloMin;
      const matchEloMax = match.eloMax;
      
      // Check if this user's ELO falls within the match's ELO range (if specified)
      const withinMatchMinElo = matchEloMin === null || userElo >= matchEloMin;
      const withinMatchMaxElo = matchEloMax === null || userElo <= matchEloMax;
      
      return withinMatchMinElo && withinMatchMaxElo;
    });
    
    if (compatibleMatches.length === 0) {
      log(`No compatible matches found for user ${userId}`, 'debug', 'MATCHMAKING');
      return null; // No matches found
    }
    
    // Get the match based on mode (closest ELO for precise, longest wait for fast)
    let match;
    
    if (matchmakingMode === "precise") {
      // For precise mode, find the closest ELO match
      match = compatibleMatches.reduce((closest, current) => {
        const closestDiff = Math.abs(closest.user.elo - userElo);
        const currentDiff = Math.abs(current.user.elo - userElo);
        return currentDiff < closestDiff ? current : closest;
      }, compatibleMatches[0]);
    } else if (matchmakingMode === "fast") {
      // For fast mode, just take the first (which should be oldest in queue)
      match = compatibleMatches[0];
    } else {
      // For balanced mode, use a weighted approach (70% ELO closeness, 30% wait time)
      match = compatibleMatches.reduce((best, current) => {
        // Normalize ELO difference (0-1 scale where 0 is perfect match)
        const bestEloDiff = Math.abs(best.user.elo - userElo) / maxRange;
        const currentEloDiff = Math.abs(current.user.elo - userElo) / maxRange;
        
        // Normalize wait time (0-1 scale where 1 is longest wait)
        const bestWaitTime = (Date.now() - new Date(best.joinedAt).getTime()) / (10 * 60 * 1000); // Normalize to 10 minutes
        const currentWaitTime = (Date.now() - new Date(current.joinedAt).getTime()) / (10 * 60 * 1000);
        
        // Calculate weighted score (lower is better)
        const bestScore = (bestEloDiff * 0.7) - (bestWaitTime * 0.3);
        const currentScore = (currentEloDiff * 0.7) - (currentWaitTime * 0.3);
        
        return currentScore < bestScore ? current : best;
      }, compatibleMatches[0]);
    }
    
    const eloDifference = Math.abs(userElo - match.user.elo);
    
    log(`Found compatible match: user ${userId} (${username}, ELO ${userElo}) with user ${match.userId} (${match.user.username}, ELO ${match.user.elo})`, 'info', 'MATCHMAKING');
    log(`ELO difference: ${eloDifference} points using ${matchmakingMode} mode`, 'debug', 'MATCHMAKING');
    
    // Create a game room with a more recognizable ID format (like agar.io and chess.com)
    // Format: ELO_RANGE-GAME_TYPE-RANDOM_ID
    const eloRangeBracket = Math.round(userElo / 100) * 100; // Round to nearest hundred
    const gameType = "1v1";
    const randomId = Math.random().toString(36).substring(2, 5).toUpperCase();
    const roomId = `${eloRangeBracket}-${gameType}-${randomId}`;
    
    // Get default game mode configuration
    const gameMode = 'classic'; // Default game mode for matchmaking
    
    // Use default values if gameModes is not available
    let modeConfig = {
        initialGold: 500,
        miningRate: 50,
        unitStats: {
            miner: { health: 100, speed: 1.0, cost: 100 },
            soldier: { health: 200, damage: 10, speed: 1.0, cost: 200 },
            barrier: { health: 300, cost: 50 }
        }
    };
    
    // Try to get the game mode config if available
    try {
        if (typeof gameModes !== 'undefined' && gameModes[gameMode]) {
            modeConfig = gameModes[gameMode];
            log(`Using ${gameMode} game mode configuration`, 'debug');
        } else {
            log(`GameModes not defined or ${gameMode} mode not found, using default config`, 'warn');
        }
    } catch (e) {
        log(`Error accessing gameModes: ${e}, using default config`, 'error');
    }
    
    // Create match record in database
    const dbMatch = await prisma.match.create({
      data: {
        player1Id: userId,
        player2Id: match.userId,
        completed: false,
        gameMode: gameMode  // Add the gameMode field
      }
    });
    log(`Created match record in database, ID: ${dbMatch.id}`, 'debug', 'MATCHMAKING');
    
    // Remove both users from the queue
    await prisma.pairingQueue.deleteMany({
      where: {
        userId: { in: [userId, match.userId] }
      }
    });
    log(`Removed users ${userId} and ${match.userId} from matchmaking queue`, 'debug', 'MATCHMAKING');
    
    // Properly initialize room data structure
    const room = {
      Started: false,
      gameMode: gameMode,
      matchId: dbMatch.id,  // Store match ID for ELO updates later
      players: [
        {
          socketId: null, // Will be set when they join the room
          username: userQueue.user.username,
          isHost: true,
          userId: userId,
          disconnected: false,
          ready: false,
          elo: userElo
        },
        {
          socketId: null, // Will be set when they join the room
          username: match.user.username,
          isHost: false,
          userId: match.userId,
          disconnected: false,
          ready: false,
          elo: match.user.elo
        }
      ],
      // Initialize server-side game state structure
      serverGameState: {
        started: false,
        gold: {},
        units: [],
        hp: {},
        lastUpdateTime: Date.now()
      },
      // Add match metadata
      matchData: {
        matchId: dbMatch.id,
        createdAt: new Date(),
        mode: gameMode,
        eloDifference: eloDifference,
        matchmakingMode: matchmakingMode
      }
    };
    
    // Store room in memory
    rooms.set(roomId, room);
    log(`Created room ${roomId} in memory with ${room.players.length} players`, 'info', 'ROOM_EVENTS');
    
    // Create result object
    const matchResult = {
      roomId,
      player1: {
        id: userId,
        elo: userElo,
        username: userQueue.user.username
      },
      player2: {
        id: match.userId,
        elo: match.user.elo,
        username: match.user.username
      },
      matchmakingMode
    };
    
    // Update both users' lastRoom
    await prisma.user.update({
      where: { id: userId },
      data: { lastRoom: roomId }
    });
    
    await prisma.user.update({
      where: { id: match.userId },
      data: { lastRoom: roomId }
    });
    log(`Updated lastRoom to ${roomId} for both players`, 'debug', 'MATCHMAKING');
    
    // Find all connected sockets for both users
    const player1Sockets = [];
    const player2Sockets = [];
    
    // Optimized socket search - check if each socket belongs to either player
    io.sockets.sockets.forEach(socket => {
      const sessionUserId = socket.request?.session?.userId;
      if (sessionUserId === userId) {
        player1Sockets.push(socket.id);
      } else if (sessionUserId === match.userId) {
        player2Sockets.push(socket.id);
      }
    });
    
    log(`Notifying matched players: ${player1Sockets.length} sockets for player1, ${player2Sockets.length} sockets for player2`, 'debug', 'MATCHMAKING');
    
    // Emit to all sockets for player 1
    if (player1Sockets.length > 0) {
      player1Sockets.forEach(socketId => {
        io.to(socketId).emit('matchFound', {
          roomId,
          opponent: match.user.username,
          opponentElo: match.user.elo,
          isHost: true,
          eloDifference,
          matchmakingMode
        });
        log(`Sent matchFound event to socket ${socketId} for player 1`, 'debug', 'MATCHMAKING');
      });
    } else {
      log(`No active sockets found for player 1 (${userId})`, 'warn', 'MATCHMAKING');
    }
    
    // Emit to all sockets for player 2
    if (player2Sockets.length > 0) {
      player2Sockets.forEach(socketId => {
        io.to(socketId).emit('matchFound', {
          roomId,
          opponent: userQueue.user.username,
          opponentElo: userElo,
          isHost: false,
          eloDifference,
          matchmakingMode
        });
        log(`Sent matchFound event to socket ${socketId} for player 2`, 'debug', 'MATCHMAKING');
      });
    } else {
      log(`No active sockets found for player 2 (${match.userId})`, 'warn', 'MATCHMAKING');
    }
    
    log(`Match created: ${userQueue.user.username} (${userId}, ELO ${userElo}) vs ${match.user.username} (${match.userId}, ELO ${match.user.elo}) using ${matchmakingMode} mode`, 'success', 'MATCHMAKING');
    serverStats.matchesMade++;
    
    return matchResult;
  } catch (error) {
    log(`Error in matchmaking: ${error}`, 'error');
    return null;
  }
}

// Admin ban/unban API
app.post('/api/admin/users/:id/ban', isAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    
    if (isNaN(userId)) {
      return res.status(400).json({ error: 'Invalid user ID' });
    }
    
    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: userId }
    });
    
    if (!existingUser) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Don't allow banning admins or self
    if (existingUser.role === "ADMIN" || userId === req.session.userId) {
      return res.status(400).json({ error: 'Cannot ban administrators or yourself' });
    }
    
    // Ban user
    await prisma.user.update({
      where: { id: userId },
      data: { banStatus: "BANNED" }
    });
    
    res.json({ message: 'User banned successfully' });
  } catch (error) {
    log(`Ban user error: ${error}`, 'error');
    res.status(500).json({ error: 'Failed to ban user' });
  }
});

app.post('/api/admin/users/:id/unban', isAdmin, async (req, res) => {
  try {
    const userId = parseInt(req.params.id);
    
    if (isNaN(userId)) {
      return res.status(400).json({ error: 'Invalid user ID' });
    }
    
    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: userId }
    });
    
    if (!existingUser) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Unban user
    await prisma.user.update({
      where: { id: userId },
      data: { banStatus: "CLEAR" }
    });
    
    res.json({ message: 'User unbanned successfully' });
  } catch (error) {
    log(`Unban user error: ${error}`, 'error');
    res.status(500).json({ error: 'Failed to unban user' });
  }
});

// Google OAuth routes
app.get('/auth/google', (req, res, next) => {
    // Save the original referrer for returning to the correct page
    if (req.headers.referer) {
        req.session.returnTo = req.headers.referer;
    }
    
    // Log authentication attempt
    log(`Google auth initiated from: ${req.headers.referer || 'unknown'}`, 'info');
    
    // Proceed with Google authentication
    passport.authenticate('google', { 
        scope: ['profile', 'email'],
        prompt: 'select_account' // Always show account selector
    })(req, res, next);
});

app.get('/auth/google/callback', (req, res, next) => {
    log(`Google auth callback received with query: ${JSON.stringify(req.query)}`, 'debug');
    
    // Handle the callback with error handling
    passport.authenticate('google', { 
        failureRedirect: '/login.html?error=google-login-failed',
        failWithError: true
    }, (err, user, info) => {
        // Handle errors
        if (err) {
            log(`Google auth error: ${err.message}`, 'error');
            return res.redirect('/login.html?error=google-login-error');
        }
        
        if (!user) {
            const errorMsg = info?.message || 'Unknown authentication failure';
            log(`Google auth failed: ${errorMsg}`, 'warn');
            return res.redirect(`/login.html?error=${encodeURIComponent(errorMsg)}`);
        }
        
        // Log in the user by setting the session
        req.login(user, (loginErr) => {
            if (loginErr) {
                log(`Login error after Google auth: ${loginErr.message}`, 'error');
                return res.redirect('/login.html?error=session-error');
            }
            
            // Set session userId
            req.session.userId = user.id;
            log(`Google auth successful for user ID: ${user.id}`, 'info');
            
            // Check if there's a return path in the session
            if (req.session.returnTo) {
                const returnUrl = req.session.returnTo;
                delete req.session.returnTo;
                return res.redirect(returnUrl);
            }
            
            // Default redirect to dashboard
            res.redirect('/dashboard.html');
        });
    })(req, res, next);
});

// Route for linking existing account with Google
app.get('/auth/google/link', isAuthenticated, (req, res) => {
    // Store the user ID in the session to connect after Google auth
    req.session.linkGoogleToUserId = req.session.userId;
    
    // Store return path
    if (req.headers.referer) {
        req.session.returnTo = req.headers.referer;
    }
    
    log(`Google account linking initiated for user ID: ${req.session.userId}`, 'info');
    
    // Redirect to Google auth with a special 'link' parameter
    passport.authenticate('google', { 
        scope: ['profile', 'email'],
        prompt: 'select_account', // Always show account selector
        state: 'linking-account'
    })(req, res);
});

// Separate callback handler for account linking
app.get('/auth/google/link/callback', (req, res, next) => {
    passport.authenticate('google', { 
        failureRedirect: '/dashboard.html?error=google-link-failed',
        failWithError: true
    }, (err, user, info) => {
        // Handle errors
        if (err) {
            log(`Google link error: ${err.message}`, 'error');
            return res.redirect('/dashboard.html?error=google-link-error');
        }
        
        if (!user) {
            const errorMsg = info?.message || 'Unknown linking failure';
            log(`Google link failed: ${errorMsg}`, 'warn');
            return res.redirect(`/dashboard.html?error=${encodeURIComponent(errorMsg)}`);
        }
        
        // Make sure the user ID is in the session
        req.session.userId = user.id;
        log(`Google account linked successfully for user ID: ${user.id}`, 'info');
        
        // Check if there's a return path
        if (req.session.returnTo) {
            const returnUrl = req.session.returnTo;
            delete req.session.returnTo;
            return res.redirect(`${returnUrl}?success=google-linked`);
        }
        
        // Default redirect to dashboard with success message
        res.redirect('/dashboard.html?success=google-linked');
    })(req, res, next);
});

// Check Google authentication status
app.get('/api/auth/google/status', (req, res) => {
  res.json({
    isAuthenticated: !!req.user,
    user: req.user ? {
      id: req.user.id,
      username: req.user.username,
      role: req.user.role
    } : null
  });
});

// Unlink Google account
app.post('/api/auth/google/unlink', isAuthenticated, async (req, res) => {
  try {
    // Update user to remove Google ID
    await prisma.user.update({
      where: { id: req.session.userId },
      data: { 
        googleId: null,
        email: null  // Optionally remove the email too if it came from Google
      }
    });
    
    res.json({ success: true, message: 'Google account unlinked successfully' });
  } catch (error) {
    log(`Error unlinking Google account: ${error}`, 'error');
    res.status(500).json({ error: 'Failed to unlink Google account' });
    }
});

// Serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

// Add a new API endpoint to get the current user count
app.get('/api/users/count', (req, res) => {
    res.json({ count: onlineUserCount });
});

// Add an endpoint to manually check for matches (for debugging and testing)
app.post('/api/pairing/check-matches', isAuthenticated, async (req, res) => {
    try {
        const userId = req.session.userId;
        
        // Check if user is in queue
        const queueEntry = await prisma.pairingQueue.findUnique({
            where: { userId }
        });
        
        if (!queueEntry) {
            return res.status(400).json({ error: 'You are not in the matchmaking queue' });
        }
        
        // Try to find a match
        const matchResult = await tryMatchmaking(userId);
        
        if (matchResult) {
            // Match was already created in tryMatchmaking
            return res.status(201).json({
                message: 'Match found! Redirecting to game room...',
                matched: true,
                roomId: matchResult.roomId,
                opponent: matchResult.player1.id === userId ? matchResult.player2.username : matchResult.player1.username
            });
        } else {
            log(`No match found for user ${userId}, added to queue`, 'info');
            
            // Schedule continuous matchmaking attempts if not already running
            setupMatchmakingInterval();
            
            return res.status(201).json({
                message: 'Joined matchmaking queue',
                matched: false
            });
        }
    } catch (error) {
        log(`Error checking matches: ${error}`, 'error');
        res.status(500).json({ error: 'Failed to check matches' });
    }
});

console.log('=========== SERVER INITIALIZATION STARTED ===========');

httpServer.listen(PORT, () => {
  console.log(`=========== SERVER STARTED ON PORT ${PORT} ===========`);
  log(`Server is running on http://localhost:${PORT}`, 'success');
  log(`Website "天下太平" is now available!`, 'success');
  log(`Type 'help' for a list of available commands`, 'info');
  
  // Set up continuous matchmaking if not already running
  setupMatchmakingInterval();
});

// Function to update ELO ratings after a match completes (using chess.com-like algorithm)
async function updateEloRatings(matchId, winnerId) {
  try {
    // Import the ELO rating library
    const EloRating = require('elo-rating');
    
    // Get match details from database
    const match = await prisma.match.findUnique({
      where: { id: matchId },
      include: {
        player1: true,
        player2: true
      }
    });
    
    if (!match) {
      log(`Unable to update ELO: Match ${matchId} not found`, 'error');
      return false;
    }
    
    // Get player info
    const player1 = match.player1;
    const player2 = match.player2;
    
    // Determine winner and loser
    let winner, loser;
    if (winnerId === player1.id) {
      winner = player1;
      loser = player2;
    } else if (winnerId === player2.id) {
      winner = player2;
      loser = player1;
    } else {
      log(`Invalid winner ID ${winnerId} for match ${matchId}`, 'error');
      return false;
    }
    
    // Calculate ELO change using the elo-rating library
    // K-factor of 32 is standard for players under 2100 rating
    const kFactor = 32;
    
    // Calculate the new ratings using the library
    const result = EloRating.calculate(winner.elo, loser.elo, true, kFactor);
    
    // Get the ELO changes
    const newWinnerElo = result.playerRating;
    const newLoserElo = result.opponentRating;
    
    // Calculate changes
    const finalWinnerGain = newWinnerElo - winner.elo;
    const finalLoserLoss = loser.elo - newLoserElo;
    
    log(`ELO Update for match ${matchId}: ${winner.username} (${winner.elo} → ${newWinnerElo}, +${finalWinnerGain}), ${loser.username} (${loser.elo} → ${newLoserElo}, -${finalLoserLoss})`, 'info', 'MATCHMAKING');
    
    // Update player ELO ratings in database
    await prisma.user.update({
      where: { id: winner.id },
      data: { elo: newWinnerElo }
    });
    
    await prisma.user.update({
      where: { id: loser.id },
      data: { elo: newLoserElo }
    });
    
    // Update match record with results
    await prisma.match.update({
      where: { id: matchId },
      data: {
        completed: true,
        winnerId: winner.id,
        winnerEloChange: finalWinnerGain,
        loserEloChange: -finalLoserLoss,
        completedAt: new Date()
      }
    });
    
    return {
      winner: {
        id: winner.id,
        username: winner.username,
        oldElo: winner.elo,
        newElo: newWinnerElo,
        change: finalWinnerGain
      },
      loser: {
        id: loser.id,
        username: loser.username,
        oldElo: loser.elo,
        newElo: newLoserElo,
        change: -finalLoserLoss
      }
    };
  } catch (error) {
    log(`Error updating ELO ratings: ${error}`, 'error');
    return false;
  }
}

// Add an API endpoint to get a user's recent matches
app.get('/api/matches/recent', isAuthenticated, async (req, res) => {
  try {
    const userId = req.session.userId;
    
    // Find matches where the user was either player1 or player2
    const recentMatches = await prisma.match.findMany({
      where: {
        OR: [
          { player1Id: userId },
          { player2Id: userId }
        ],
        completed: true
      },
      include: {
        player1: {
          select: {
            id: true,
            username: true,
            elo: true
          }
        },
        player2: {
          select: {
            id: true,
            username: true,
            elo: true
          }
        },
        winner: {
          select: {
            id: true
          }
        }
      },
      orderBy: {
        completedAt: 'desc'
      },
      take: 10 // Limit to 10 most recent matches
    });
    
    // Format the matches for the client
    const formattedMatches = recentMatches.map(match => {
      const isPlayer1 = match.player1Id === userId;
      const opponent = isPlayer1 ? match.player2 : match.player1;
      const userWon = match.winnerId === userId;
      
      // Determine result and ELO change
      let result;
      let eloChange;
      
      if (match.winnerId === null) {
        result = 'draw';
        eloChange = '+0';
      } else if (userWon) {
        result = 'win';
        eloChange = `+${match.winnerEloChange || 0}`;
      } else {
        result = 'loss';
        eloChange = `${match.loserEloChange || 0}`; // Already negative
      }
      
      return {
        id: match.id,
        opponent: opponent.username,
        opponentElo: opponent.elo,
        result,
        eloChange,
        date: match.completedAt || match.updatedAt
      };
    });
    
    res.json(formattedMatches);
  } catch (error) {
    log(`Error retrieving recent matches: ${error}`, 'error');
    res.status(500).json({ error: 'Failed to retrieve recent matches' });
  }
});

// ===== Test Functions =====

// Matchmaking system test
async function testMatchmaking() {
  try {
    log(`Running matchmaking system test...`, 'info');

    // Create test users if they don't exist
    let testUser1 = await prisma.user.findUnique({
      where: { username: 'testuser1' }
    });

    let testUser2 = await prisma.user.findUnique({
      where: { username: 'testuser2' }
    });

    if (!testUser1) {
      testUser1 = await prisma.user.create({
        data: {
          username: 'testuser1',
          password: 'password',
          elo: 1200
        }
      });
      log(`Created test user 1`, 'info');
    }

    if (!testUser2) {
      testUser2 = await prisma.user.create({
        data: {
          username: 'testuser2',
          password: 'password',
          elo: 1200
        }
      });
      log(`Created test user 2`, 'info');
    }

    // Make sure users are not in queue already
    await prisma.pairingQueue.deleteMany({
      where: {
        userId: { in: [testUser1.id, testUser2.id] }
      }
    });

    // Add test user 1 to queue
    await prisma.pairingQueue.create({
      data: {
        userId: testUser1.id
      }
    });
    log(`Added test user 1 to queue`, 'info');

    // Add test user 2 to queue
    await prisma.pairingQueue.create({
      data: {
        userId: testUser2.id
      }
    });
    log(`Added test user 2 to queue`, 'info');

    // Manually trigger matchmaking for test user 1
    const matchResult = await tryMatchmaking(testUser1.id);

    if (matchResult) {
      log(`✅ Test passed: Match was successfully created`, 'success');
      log(`Match details: ${JSON.stringify(matchResult)}`, 'info');

      // Verify the created match record
      const match = await prisma.match.findUnique({
        where: { id: parseInt(matchResult.roomId.split('-').pop()) }
      });

      if (match) {
        log(`✅ Test passed: Match record created in database with gameMode: ${match.gameMode}`, 'success');
      } else {
        log(`❌ Test failed: No match record found in database`, 'error');
      }
    } else {
      log(`❌ Test failed: No match was created`, 'error');
    }

    // Clean up
    await prisma.pairingQueue.deleteMany({
      where: {
        userId: { in: [testUser1.id, testUser2.id] }
      }
    });
    log(`Test completed and cleaned up`, 'info');

    return true;
  } catch (error) {
    log(`Test error: ${error}`, 'error');
    return false;
  }
}

// Add a test command to the command handlers
const commands = {
    help: {
        description: 'Shows all available commands',
        execute: () => {
            log('Available commands:', 'success');
            Object.entries(commands).forEach(([name, cmd]) => {
                console.log(`  ${name.padEnd(15)} - ${cmd.description}`);
            });
            return true;
        }
    },
    
    status: {
        description: 'Shows server status information',
        execute: () => {
            const uptime = Date.now() - serverStats.startTime;
            const uptimeHours = Math.floor(uptime / (1000 * 60 * 60));
            const uptimeMinutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
            
            log('Server status:', 'success');
            console.log(`  Uptime:             ${uptimeHours}h ${uptimeMinutes}m`);
            console.log(`  Online users:       ${onlineUserCount}`);
            console.log(`  Active rooms:       ${rooms.size}`);
            console.log(`  Matches made:       ${serverStats.matchesMade}`);
            console.log(`  Commands executed:  ${serverStats.commandsExecuted}`);
            console.log(`  Errors:             ${serverStats.errors}`);
            return true;
        }
    },
    
    // ... other commands ...
    
    test: {
        description: 'Run system tests',
        execute: async (args) => {
            if (args.length > 0 && args[0] === 'matchmaking') {
                log('Running matchmaking test...', 'info');
                const result = await testMatchmaking();
                return result;
            } else {
                log('Available tests: matchmaking', 'info');
                return true;
            }
        }
    }
};
